package random

import (
	"crypto/ecdsa"
	crand "crypto/rand"
	"fmt"

	"github.com/Layr-Labs/eigenda/core"
	"github.com/consensys/gnark-crypto/ecc/bn254/fr"
	"github.com/ethereum/go-ethereum/crypto"

	"io"
	"math/big"
	"math/rand"
	"time"
)

// charset is the set of characters that can be used to generate random strings
const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

// TestRandom provides all the functionality of math/rand.Rand, plus additional randomness functionality useful for testing
type TestRandom struct {
	// The source of randomness
	*rand.Rand

	// The seed used to initialize the random number generator
	seed int64
}

// NewTestRandom creates a new instance of TestRandom
// This method may either be seeded, or not seeded. If no seed is provided, then current unix nano time is used.
func NewTestRandom(fixedSeed ...int64) *TestRandom {
	return newTestRandom(true, fixedSeed...)
}

// NewTestRandomNoPrint is similar to NewTestRandom, but does not print the seed to stdout.
func NewTestRandomNoPrint(fixedSeed ...int64) *TestRandom {
	return newTestRandom(false, fixedSeed...)
}

// NewTestRandomNoSeed creates a new instance of TestRandom.
func newTestRandom(print bool, fixedSeed ...int64) *TestRandom {
	var seed int64
	if len(fixedSeed) == 0 {
		seed = time.Now().UnixNano()
	} else if len(fixedSeed) == 1 {
		seed = fixedSeed[0]
	} else {
		panic("too many arguments, expected exactly one seed")
	}

	if print {
		fmt.Printf("Random seed: %d\n", seed)
	}
	return &TestRandom{
		Rand: rand.New(rand.NewSource(seed)),
		seed: seed,
	}
}

// Reset resets the random number generator to the state it was in when it was first created.
// This method is not thread safe with respect to other methods in this struct.
func (r *TestRandom) Reset() {
	r.Seed(r.seed)
}

// Bytes generates a random byte slice of a given length.
func (r *TestRandom) Bytes(length int) []byte {
	bytes := make([]byte, length)
	_, err := r.Read(bytes)
	if err != nil {
		panic(err)
	}
	return bytes
}

// VariableBytes generates a random byte slice of a length between min (inclusive) and max (exclusive).
func (r *TestRandom) VariableBytes(min int, max int) []byte {
	length := r.Intn(max-min) + min
	return r.Bytes(length)
}

// PrintableBytes generates a random byte slice of a given length, containing only printable ASCII characters.
// Useful for scenarios where a human needs to make sense of the generated bytes during debugging.
func (r *TestRandom) PrintableBytes(length int) []byte {
	return []byte(r.String(length))
}

// PrintableVariableBytes generates a random byte slice of a length between min (inclusive) and max (exclusive),
// containing only printable ASCII characters. Useful for scenarios where a human needs to make sense of the
// generated bytes during debugging.
func (r *TestRandom) PrintableVariableBytes(min int, max int) []byte {
	return []byte(r.VariableString(min, max))
}

// Time generates a random time. Chooses a value no later than 100 years after the epoch to avoid overflow issues
// (allows the timestamp to be stored as nanoseconds in a 64-bit integer).
func (r *TestRandom) Time() time.Time {
	years := r.Intn(100)
	months := r.Intn(12)
	days := r.Intn(31)
	hours := r.Intn(24)
	minutes := r.Intn(60)
	seconds := r.Intn(60)
	nanos := r.Intn(1000000000)
	return time.Date(1970+years, time.Month(months+1), days+1, hours, minutes, seconds, nanos, time.UTC)
}

// TimeInRange generates a random time between min (inclusive) and max (exclusive).
func (r *TestRandom) TimeInRange(min time.Time, max time.Time) time.Time {
	return min.Add(time.Duration(r.Int63n(int64(max.Sub(min)))))
}

// String generates a random string out of printable ASCII characters.
func (r *TestRandom) String(length int) string {
	b := make([]byte, length)
	for i := range b {
		b[i] = charset[r.Intn(len(charset))]
	}
	return string(b)
}

// VariableString generates a random string out of printable ASCII characters of a length between
// min (inclusive) and max (exclusive).
func (r *TestRandom) VariableString(min int, max int) string {
	length := r.Intn(max-min) + min
	return r.String(length)
}

// Uint32n generates a random uint32 less than n.
func (r *TestRandom) Uint32n(n uint32) uint32 {
	return r.Uint32() % n
}

// Uint64n generates a random uint64 less than n.
func (r *TestRandom) Uint64n(n uint64) uint64 {
	return r.Uint64() % n
}

// Gaussian generates a random float64 from a Gaussian distribution with the given mean and standard deviation.
func (r *TestRandom) Gaussian(mean float64, stddev float64) float64 {
	return r.NormFloat64()*stddev + mean
}

// BoundedGaussian generates a random float64 from a Gaussian distribution with the given mean and standard deviation,
// but bounded by the given min and max values. If a generated value exceeds the bounds, the bound is returned instead.
func (r *TestRandom) BoundedGaussian(mean float64, stddev float64, min float64, max float64) float64 {
	val := r.Gaussian(mean, stddev)
	if val < min {
		return min
	}
	if val > max {
		return max
	}
	return val
}

var _ io.Reader = &randIOReader{}

// randIOReader is an io.Reader that reads from a random number generator.
type randIOReader struct {
	rand *TestRandom
}

// Read reads random bytes into the provided buffer, returning the number of bytes read.
func (i *randIOReader) Read(p []byte) (n int, err error) {
	return i.rand.Read(p)
}

// IOReader creates an io.Reader that reads from a random number generator.
func (r *TestRandom) IOReader() io.Reader {
	return &randIOReader{r}
}

// ECDSA generates a random ECDSA key. Note that the returned keys are not deterministic due to limitations
// **intentionally** imposed by the Go standard libraries. (╯°□°)╯︵ ┻━┻
//
// NOT CRYPTOGRAPHICALLY SECURE!!! FOR TESTING PURPOSES ONLY. DO NOT USE THESE KEYS FOR SECURITY PURPOSES.
func (r *TestRandom) ECDSA() (*ecdsa.PublicKey, *ecdsa.PrivateKey, error) {
	key, err := ecdsa.GenerateKey(crypto.S256(), crand.Reader)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to generate key: %w", err)
	}
	return &key.PublicKey, key, nil
}

// BLS generates a random BLS key pair.
//
// NOT CRYPTOGRAPHICALLY SECURE!!! FOR TESTING PURPOSES ONLY. DO NOT USE THESE KEYS FOR SECURITY PURPOSES.
func (r *TestRandom) BLS() (*core.KeyPair, error) {
	//Max random value is order of the curve
	maxValue := new(big.Int)
	maxValue.SetString(fr.Modulus().String(), 10)

	//Generate cryptographically strong pseudo-random between 0 - max
	n, err := crand.Int(r.IOReader(), maxValue)
	if err != nil {
		return nil, fmt.Errorf("failed to generate random number: %w", err)
	}

	sk := new(core.PrivateKey).SetBigInt(n)
	return core.MakeKeyPair(sk), nil
}

// Bool generates a random boolean.
func (r *TestRandom) Bool() bool {
	return r.BoolWithProbability(0.5)
}

// BoolWithProbability generates a random boolean with a given probability of being true.
func (r *TestRandom) BoolWithProbability(probability float64) bool {
	return r.Float64() < probability
}

// Uint32Range generates a random uint32 between min (inclusive) and max (exclusive).
func (r *TestRandom) Uint32Range(min uint32, max uint32) uint32 {
	return r.Uint32()%(max-min) + min
}

// Uint64Range generates a random uint64 between min (inclusive) and max (exclusive).
func (r *TestRandom) Uint64Range(min uint64, max uint64) uint64 {
	return r.Uint64()%(max-min) + min
}

// Int32Range generates a random int32 between min (inclusive) and max (exclusive).
func (r *TestRandom) Int32Range(min, max int32) int32 {
	return r.Int31n(max-min) + min
}

// Int64Range generates a random int64 between min (inclusive) and max (exclusive).
func (r *TestRandom) Int64Range(min, max int64) int64 {
	return r.Int63n(max-min) + min
}

// Float32Range generates a random float32 between min (inclusive) and max (exclusive).
func (r *TestRandom) Float32Range(min, max float32) float32 {
	return r.Float32()*(max-min) + min
}

// Float64Range generates a random float64 between min (inclusive) and max (exclusive).
func (r *TestRandom) Float64Range(min, max float64) float64 {
	return r.Float64()*(max-min) + min
}
