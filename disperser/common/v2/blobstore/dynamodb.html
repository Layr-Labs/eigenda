
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>blobstore: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Layr-Labs/eigenda/disperser/common/v2/blobstore/dynamo_metadata_store.go (78.6%)</option>
				
				<option value="file1">github.com/Layr-Labs/eigenda/disperser/common/v2/blobstore/metadata_store.go (86.3%)</option>
				
				<option value="file2">github.com/Layr-Labs/eigenda/disperser/common/v2/blobstore/postgres_metadata_store.go (0.0%)</option>
				
				<option value="file3">github.com/Layr-Labs/eigenda/disperser/common/v2/blobstore/s3_blob_store.go (66.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package blobstore

import (
        "context"
        "encoding/hex"
        "errors"
        "fmt"
        "math"
        "strconv"
        "strings"
        "time"

        "github.com/Layr-Labs/eigenda/api"
        commondynamodb "github.com/Layr-Labs/eigenda/common/aws/dynamodb"
        "github.com/Layr-Labs/eigenda/core"
        corev2 "github.com/Layr-Labs/eigenda/core/v2"
        "github.com/Layr-Labs/eigenda/disperser/common"
        v2 "github.com/Layr-Labs/eigenda/disperser/common/v2"
        "github.com/Layr-Labs/eigenda/encoding"
        "github.com/Layr-Labs/eigensdk-go/logging"
        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
        gethcommon "github.com/ethereum/go-ethereum/common"
)

const (
        StatusIndexName            = "StatusIndex"
        OperatorDispersalIndexName = "OperatorDispersalIndex"
        OperatorResponseIndexName  = "OperatorResponseIndex"
        RequestedAtIndexName       = "RequestedAtIndex"
        AttestedAtIndexName        = "AttestedAtAIndex"
        AccountBlobIndexName       = "AccountBlobIndex"

        blobKeyPrefix             = "BlobKey#"
        dispersalKeyPrefix        = "Dispersal#"
        batchHeaderKeyPrefix      = "BatchHeader#"
        blobMetadataSK            = "BlobMetadata"
        blobCertSK                = "BlobCertificate"
        dispersalRequestSKPrefix  = "DispersalRequest#"
        dispersalResponseSKPrefix = "DispersalResponse#"
        batchHeaderSK             = "BatchHeader"
        batchSK                   = "BatchInfo"
        attestationSK             = "Attestation"

        // The number of nanoseconds for a requestedAt bucket (1h).
        // The rationales are:
        // - 1h would be a good estimate for blob feed request (e.g. fetch blobs in past hour can be a common use case)
        // - at 100 blobs/s, it'll be 360,000 blobs in a bucket, which is reasonable
        // - and then it'll be 336 buckets in total (24 buckets/day * 14 days), which is also reasonable
        requestedAtBucketSizeNano = uint64(time.Hour / time.Nanosecond)
        // 14 days with 1 hour margin of safety.
        maxBlobAgeInNano = uint64((14*24*time.Hour + 1*time.Hour) / time.Nanosecond)

        // The number of nanoseconds for an attestedAt bucket (1d)
        // - 1d would be a good estimate for attestation needs (e.g. signing rate over past 24h is a common use case)
        // - even at 1 attesation/s, it'll be 86,400 attestations in a bucket, which is reasonable
        attestedAtBucketSizeNano = uint64(24 * time.Hour / time.Nanosecond)
)

var (
        statusUpdatePrecondition = map[v2.BlobStatus][]v2.BlobStatus{
                v2.Queued:              {},
                v2.Encoded:             {v2.Queued},
                v2.GatheringSignatures: {v2.Encoded},
                v2.Complete:            {v2.GatheringSignatures},
                v2.Failed:              {v2.Queued, v2.Encoded, v2.GatheringSignatures},
        }
        ErrInvalidStateTransition = errors.New("invalid state transition")
)

var _ MetadataStore = (*BlobMetadataStore)(nil)

// BlobMetadataStore is a blob metadata storage backed by DynamoDB
type BlobMetadataStore struct {
        dynamoDBClient commondynamodb.Client
        logger         logging.Logger
        tableName      string
}

func NewBlobMetadataStore(dynamoDBClient commondynamodb.Client, logger logging.Logger, tableName string) *BlobMetadataStore <span class="cov8" title="1">{
        logger.Debugf("creating blob metadata store v2 with table %s", tableName)
        return &amp;BlobMetadataStore{
                dynamoDBClient: dynamoDBClient,
                logger:         logger.With("component", "blobMetadataStoreV2"),
                tableName:      tableName,
        }
}</span>

func (s *BlobMetadataStore) PutBlobMetadata(ctx context.Context, blobMetadata *v2.BlobMetadata) error <span class="cov8" title="1">{
        s.logger.Debug("store put blob metadata", "blobMetadata", blobMetadata)
        item, err := MarshalBlobMetadata(blobMetadata)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = s.dynamoDBClient.PutItemWithCondition(ctx, s.tableName, item, "attribute_not_exists(PK) AND attribute_not_exists(SK)", nil, nil)
        if errors.Is(err, commondynamodb.ErrConditionFailed) </span><span class="cov8" title="1">{
                return common.ErrAlreadyExists
        }</span>

        <span class="cov8" title="1">return err</span>
}

func (s *BlobMetadataStore) UpdateBlobStatus(ctx context.Context, blobKey corev2.BlobKey, status v2.BlobStatus) error <span class="cov8" title="1">{
        validStatuses := statusUpdatePrecondition[status]
        if len(validStatuses) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: invalid status transition to %s", ErrInvalidStateTransition, status.String())
        }</span>

        <span class="cov8" title="1">expValues := make([]expression.OperandBuilder, len(validStatuses))
        for i, validStatus := range validStatuses </span><span class="cov8" title="1">{
                expValues[i] = expression.Value(int(validStatus))
        }</span>
        <span class="cov8" title="1">condition := expression.Name("BlobStatus").In(expValues[0], expValues[1:]...)
        _, err := s.dynamoDBClient.UpdateItemWithCondition(ctx, s.tableName, map[string]types.AttributeValue{
                "PK": &amp;types.AttributeValueMemberS{
                        Value: blobKeyPrefix + blobKey.Hex(),
                },
                "SK": &amp;types.AttributeValueMemberS{
                        Value: blobMetadataSK,
                },
        }, map[string]types.AttributeValue{
                "BlobStatus": &amp;types.AttributeValueMemberN{
                        Value: strconv.Itoa(int(status)),
                },
                "UpdatedAt": &amp;types.AttributeValueMemberN{
                        Value: strconv.FormatInt(time.Now().UnixNano(), 10),
                },
        }, condition)

        if errors.Is(err, commondynamodb.ErrConditionFailed) </span><span class="cov8" title="1">{
                blob, err := s.GetBlobMetadata(ctx, blobKey)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get blob metadata for key %s: %v", blobKey.Hex(), err)
                }</span>

                <span class="cov8" title="1">if blob.BlobStatus == status </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: blob already in status %s", common.ErrAlreadyExists, status.String())
                }</span>

                <span class="cov8" title="1">return fmt.Errorf("%w: invalid status transition from %s to %s", ErrInvalidStateTransition, blob.BlobStatus.String(), status.String())</span>
        }

        <span class="cov8" title="1">return err</span>
}

func (s *BlobMetadataStore) DeleteBlobMetadata(ctx context.Context, blobKey corev2.BlobKey) error <span class="cov8" title="1">{
        err := s.dynamoDBClient.DeleteItem(ctx, s.tableName, map[string]types.AttributeValue{
                "PK": &amp;types.AttributeValueMemberS{
                        Value: blobKeyPrefix + blobKey.Hex(),
                },
                "SK": &amp;types.AttributeValueMemberS{
                        Value: blobMetadataSK,
                },
        })

        return err
}</span>

func (s *BlobMetadataStore) GetBlobMetadata(ctx context.Context, blobKey corev2.BlobKey) (*v2.BlobMetadata, error) <span class="cov8" title="1">{
        item, err := s.dynamoDBClient.GetItem(ctx, s.tableName, map[string]types.AttributeValue{
                "PK": &amp;types.AttributeValueMemberS{
                        Value: blobKeyPrefix + blobKey.Hex(),
                },
                "SK": &amp;types.AttributeValueMemberS{
                        Value: blobMetadataSK,
                },
        })

        if item == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: metadata not found for key %s", common.ErrMetadataNotFound, blobKey.Hex())
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">metadata, err := UnmarshalBlobMetadata(item)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return metadata, nil</span>
}

// CheckBlobExists checks if a blob exists without fetching the entire metadata.
func (s *BlobMetadataStore) CheckBlobExists(ctx context.Context, blobKey corev2.BlobKey) (bool, error) <span class="cov8" title="1">{
        input := &amp;dynamodb.GetItemInput{
                TableName: aws.String(s.tableName),
                Key: map[string]types.AttributeValue{
                        "PK": &amp;types.AttributeValueMemberS{
                                Value: blobKeyPrefix + blobKey.Hex(),
                        },
                        "SK": &amp;types.AttributeValueMemberS{
                                Value: blobMetadataSK,
                        },
                },
                ProjectionExpression: aws.String("PK"), // Only fetch the PK attribute
        }

        item, err := s.dynamoDBClient.GetItemWithInput(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check blob existence: %w", err)
        }</span>

        // If the item is not nil, the blob exists
        <span class="cov8" title="1">return item != nil, nil</span>
}

// GetBlobMetadataByStatus returns all the metadata with the given status that were updated after lastUpdatedAt
// Because this function scans the entire index, it should only be used for status with a limited number of items.
// Results are ordered by UpdatedAt in ascending order.
func (s *BlobMetadataStore) GetBlobMetadataByStatus(ctx context.Context, status v2.BlobStatus, lastUpdatedAt uint64) ([]*v2.BlobMetadata, error) <span class="cov8" title="1">{
        items, err := s.dynamoDBClient.QueryIndex(ctx, s.tableName, StatusIndexName, "BlobStatus = :status AND UpdatedAt &gt; :updatedAt", commondynamodb.ExpressionValues{
                ":status": &amp;types.AttributeValueMemberN{
                        Value: strconv.Itoa(int(status)),
                },
                ":updatedAt": &amp;types.AttributeValueMemberN{
                        Value: strconv.FormatInt(int64(lastUpdatedAt), 10),
                }})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">metadata := make([]*v2.BlobMetadata, len(items))
        for i, item := range items </span><span class="cov8" title="1">{
                metadata[i], err = UnmarshalBlobMetadata(item)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return metadata, nil</span>
}

// queryBucketBlobMetadata appends blobs (as metadata) within range (startKey, endKey) from a single bucket to the provided result slice.
// Results are ordered by &lt;RequestedAt, Bobkey&gt; in ascending order.
//
// The function handles DynamoDB's 1MB response size limitation by performing multiple queries if necessary.
// It filters out blobs at the exact startKey and endKey as they are exclusive bounds.
func (s *BlobMetadataStore) queryBucketBlobMetadata(
        ctx context.Context,
        bucket uint64,
        ascending bool,
        after BlobFeedCursor,
        before BlobFeedCursor,
        startKey string,
        endKey string,
        limit int,
        result []*v2.BlobMetadata,
        lastProcessedCursor **BlobFeedCursor,
) ([]*v2.BlobMetadata, error) <span class="cov8" title="1">{
        var lastEvaledKey map[string]types.AttributeValue
        for </span><span class="cov8" title="1">{
                remaining := math.MaxInt
                if limit &gt; 0 </span><span class="cov8" title="1">{
                        remaining = limit - len(result)
                }</span>
                <span class="cov8" title="1">res, err := s.dynamoDBClient.QueryIndexWithPagination(
                        ctx,
                        s.tableName,
                        RequestedAtIndexName,
                        "RequestedAtBucket = :pk AND RequestedAtBlobKey BETWEEN :start AND :end",
                        commondynamodb.ExpressionValues{
                                ":pk":    &amp;types.AttributeValueMemberS{Value: fmt.Sprintf("%d", bucket)},
                                ":start": &amp;types.AttributeValueMemberS{Value: startKey},
                                ":end":   &amp;types.AttributeValueMemberS{Value: endKey},
                        },
                        int32(remaining),
                        lastEvaledKey,
                        ascending,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return result, fmt.Errorf("query failed for bucket %d: %w", bucket, err)
                }</span>

                // Collect results
                <span class="cov8" title="1">for _, item := range res.Items </span><span class="cov8" title="1">{
                        bm, err := UnmarshalBlobMetadata(item)
                        if err != nil </span><span class="cov0" title="0">{
                                return result, fmt.Errorf("failed to unmarshal blob metadata: %w", err)
                        }</span>

                        // Get blob key for filtering
                        <span class="cov8" title="1">blobKey, err := bm.BlobHeader.BlobKey()
                        if err != nil </span><span class="cov0" title="0">{
                                return result, fmt.Errorf("failed to get blob key: %w", err)
                        }</span>

                        // Skip blobs at the endpoints (exclusive bounds)
                        <span class="cov8" title="1">if after.Equal(bm.RequestedAt, &amp;blobKey) || before.Equal(bm.RequestedAt, &amp;blobKey) </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        // Add to result
                        <span class="cov8" title="1">result = append(result, bm)

                        // Update last processed cursor
                        *lastProcessedCursor = &amp;BlobFeedCursor{
                                RequestedAt: bm.RequestedAt,
                                BlobKey:     &amp;blobKey,
                        }

                        // Check limit
                        if limit &gt; 0 &amp;&amp; len(result) &gt;= limit </span><span class="cov8" title="1">{
                                return result, nil
                        }</span>
                }

                // Exhausted all items already
                <span class="cov8" title="1">if res.LastEvaluatedKey == nil </span><span class="cov8" title="1">{
                        break</span>
                }
                // For next iteration
                <span class="cov8" title="1">lastEvaledKey = res.LastEvaluatedKey</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// GetBlobMetadataByRequestedAtForward returns blobs (as BlobMetadata) in cursor range
// (after, before) (both exclusive). Blobs are retrieved and ordered by &lt;RequestedAt, BlobKey&gt;
// in ascending order.
//
// If limit &gt; 0, returns at most that many blobs. If limit &lt;= 0, returns all blobs in range.
// Also returns the cursor of the last processed blob, or nil if no blobs were processed.
func (s *BlobMetadataStore) GetBlobMetadataByRequestedAtForward(
        ctx context.Context,
        after BlobFeedCursor,
        before BlobFeedCursor,
        limit int,
) ([]*v2.BlobMetadata, *BlobFeedCursor, error) <span class="cov8" title="1">{
        if !after.LessThan(&amp;before) </span><span class="cov8" title="1">{
                return nil, nil, errors.New("after cursor must be less than before cursor")
        }</span>

        <span class="cov8" title="1">startBucket, endBucket := GetRequestedAtBucketIDRange(after.RequestedAt, before.RequestedAt)
        startKey := after.ToCursorKey()
        endKey := before.ToCursorKey()
        result := make([]*v2.BlobMetadata, 0)
        var lastProcessedCursor *BlobFeedCursor

        for bucket := startBucket; bucket &lt;= endBucket; bucket++ </span><span class="cov8" title="1">{
                // Pass the result slice to be modified in-place along with cursors for filtering
                var err error
                result, err = s.queryBucketBlobMetadata(
                        ctx, bucket, true, after, before, startKey, endKey, limit, result, &amp;lastProcessedCursor,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>

                <span class="cov8" title="1">if limit &gt; 0 &amp;&amp; len(result) &gt;= limit </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return result, lastProcessedCursor, nil</span>
}

// GetBlobMetadataByRequestedAtBackward returns blobs (as BlobMetadata) in cursor range
// (after, before) (both exclusive). Blobs are retrieved and ordered by &lt;RequestedAt, BlobKey&gt;
// in descending order.
//
// If limit &gt; 0, returns at most that many blobs. If limit &lt;= 0, returns all blobs in range.
// Also returns the cursor of the last processed blob, or nil if no blobs were processed.
func (s *BlobMetadataStore) GetBlobMetadataByRequestedAtBackward(
        ctx context.Context,
        before BlobFeedCursor,
        after BlobFeedCursor,
        limit int,
) ([]*v2.BlobMetadata, *BlobFeedCursor, error) <span class="cov8" title="1">{
        if !after.LessThan(&amp;before) </span><span class="cov8" title="1">{
                return nil, nil, errors.New("after cursor must be less than before cursor")
        }</span>

        <span class="cov8" title="1">startBucket, endBucket := GetRequestedAtBucketIDRange(after.RequestedAt, before.RequestedAt)
        startKey := after.ToCursorKey()
        endKey := before.ToCursorKey()
        result := make([]*v2.BlobMetadata, 0)
        var lastProcessedCursor *BlobFeedCursor

        // Traverse buckets in reverse order
        for bucket := endBucket; bucket &gt;= startBucket; bucket-- </span><span class="cov8" title="1">{
                // Pass the result slice to be modified in-place along with cursors for filtering
                var err error
                result, err = s.queryBucketBlobMetadata(
                        ctx, bucket, false, after, before, startKey, endKey, limit, result, &amp;lastProcessedCursor,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>

                <span class="cov8" title="1">if limit &gt; 0 &amp;&amp; len(result) &gt;= limit </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return result, lastProcessedCursor, nil</span>
}

// GetBlobMetadataByAccountID returns blobs (as BlobMetadata) within time range (start, end)
// (in ns, both exclusive), retrieved and ordered by RequestedAt timestamp in specified order, for
// a given account.
//
// If specified order is ascending (`ascending` is true), retrieve data from the oldest (`start`)
// to the newest (`end`); otherwise retrieve by the opposite direction.
//
// If limit &gt; 0, returns at most that many blobs. If limit &lt;= 0, returns all results
// in the time range.
func (s *BlobMetadataStore) GetBlobMetadataByAccountID(
        ctx context.Context,
        accountId gethcommon.Address,
        start uint64,
        end uint64,
        limit int,
        ascending bool,
) ([]*v2.BlobMetadata, error) <span class="cov8" title="1">{
        if start+1 &gt; end-1 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no time point in exclusive time range (%d, %d)", start, end)
        }</span>

        <span class="cov8" title="1">blobs := make([]*v2.BlobMetadata, 0)
        var lastEvaledKey map[string]types.AttributeValue
        adjustedStart, adjustedEnd := start+1, end-1

        // Iteratively fetch results until we get desired number of items or exhaust the
        // available data.
        // This needs to be processed in a loop because DynamoDb has a limit on the response
        // size of a query (1MB) and we may have more data than that.
        for </span><span class="cov8" title="1">{
                remaining := math.MaxInt
                if limit &gt; 0 </span><span class="cov8" title="1">{
                        remaining = limit - len(blobs)
                }</span>
                <span class="cov8" title="1">res, err := s.dynamoDBClient.QueryIndexWithPagination(
                        ctx,
                        s.tableName,
                        AccountBlobIndexName,
                        "AccountID = :pk AND RequestedAt BETWEEN :start AND :end",
                        commondynamodb.ExpressionValues{
                                ":pk":    &amp;types.AttributeValueMemberS{Value: accountId.Hex()},
                                ":start": &amp;types.AttributeValueMemberN{Value: strconv.FormatInt(int64(adjustedStart), 10)},
                                ":end":   &amp;types.AttributeValueMemberN{Value: strconv.FormatInt(int64(adjustedEnd), 10)},
                        },
                        int32(remaining),
                        lastEvaledKey,
                        ascending,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("query failed for accountId %s with time range (%d, %d): %w", accountId.Hex(), adjustedStart, adjustedEnd, err)
                }</span>

                // Collect results
                <span class="cov8" title="1">for _, item := range res.Items </span><span class="cov8" title="1">{
                        it, err := UnmarshalBlobMetadata(item)
                        if err != nil </span><span class="cov0" title="0">{
                                return blobs, fmt.Errorf("failed to unmarshal blob metadata: %w", err)
                        }</span>
                        <span class="cov8" title="1">blobs = append(blobs, it)

                        // Desired number of items collected
                        if limit &gt; 0 &amp;&amp; len(blobs) &gt;= limit </span><span class="cov8" title="1">{
                                return blobs, nil
                        }</span>
                }

                // Exhausted all items already
                <span class="cov8" title="1">if res.LastEvaluatedKey == nil </span><span class="cov8" title="1">{
                        break</span>
                }
                // For next iteration
                <span class="cov0" title="0">lastEvaledKey = res.LastEvaluatedKey</span>
        }

        <span class="cov8" title="1">return blobs, nil</span>
}

// queryBucketAttestation returns attestations within a single bucket of time range [start, end]. Results are ordered by AttestedAt in
// ascending order.
//
// The function handles DynamoDB's 1MB response size limitation by performing multiple queries  if necessary.
// If there are more than numToReturn attestations in the bucket, returns numToReturn attestations; otherwise returns all attestations in bucket.
func (s *BlobMetadataStore) queryBucketAttestation(
        ctx context.Context,
        bucket, start, end uint64,
        numToReturn int,
        ascending bool,
) ([]*corev2.Attestation, error) <span class="cov8" title="1">{
        attestations := make([]*corev2.Attestation, 0)
        var lastEvaledKey map[string]types.AttributeValue

        // Iteratively fetch results from the bucket until we get desired number of items
        // or exhaust the entire bucket.
        // This needs to be processed in a loop because DynamoDb has a limit on the response
        // size of a query (1MB) and we may have more data than that.
        for </span><span class="cov8" title="1">{
                res, err := s.dynamoDBClient.QueryIndexWithPagination(
                        ctx,
                        s.tableName,
                        AttestedAtIndexName,
                        "AttestedAtBucket = :pk AND AttestedAt BETWEEN :start AND :end",
                        commondynamodb.ExpressionValues{
                                ":pk":    &amp;types.AttributeValueMemberS{Value: fmt.Sprintf("%d", bucket)},
                                ":start": &amp;types.AttributeValueMemberN{Value: strconv.FormatInt(int64(start), 10)},
                                ":end":   &amp;types.AttributeValueMemberN{Value: strconv.FormatInt(int64(end), 10)},
                        },
                        int32(numToReturn),
                        lastEvaledKey,
                        ascending,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("query failed for bucket %d: %w", bucket, err)
                }</span>

                // Collect results
                <span class="cov8" title="1">for _, item := range res.Items </span><span class="cov8" title="1">{
                        at, err := UnmarshalAttestation(item)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to unmarshal attestation: %w", err)
                        }</span>
                        <span class="cov8" title="1">attestations = append(attestations, at)

                        // Desired number of items collected
                        if len(attestations) &gt;= numToReturn </span><span class="cov8" title="1">{
                                return attestations, nil
                        }</span>
                }

                // Exhausted all items already
                <span class="cov8" title="1">if res.LastEvaluatedKey == nil </span><span class="cov8" title="1">{
                        break</span>
                }
                // For next iteration
                <span class="cov8" title="1">lastEvaledKey = res.LastEvaluatedKey</span>
        }

        <span class="cov8" title="1">return attestations, nil</span>
}

// GetAttestationByAttestedAtForward returns attestations within time range (after, before)
// (both exclusive), retrieved and ordered by AttestedAt timestamp in ascending order.
//
// The function splits the time range into buckets and queries each bucket sequentially from earliest to latest.
// Results from all buckets are combined while maintaining the ordering.
//
// If limit &gt; 0, returns at most that many attestations. If limit &lt;= 0, returns all attestations
// in the time range.
func (s *BlobMetadataStore) GetAttestationByAttestedAtForward(
        ctx context.Context,
        after uint64,
        before uint64,
        limit int,
) ([]*corev2.Attestation, error) <span class="cov8" title="1">{
        if after+1 &gt; before-1 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no time point in exclusive time range (%d, %d)", after, before)
        }</span>
        <span class="cov8" title="1">startBucket, endBucket := GetAttestedAtBucketIDRange(after, before)
        result := make([]*corev2.Attestation, 0)

        // Traverse buckets in forward order
        for bucket := startBucket; bucket &lt;= endBucket; bucket++ </span><span class="cov8" title="1">{
                if limit &gt; 0 &amp;&amp; len(result) &gt;= limit </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">remaining := math.MaxInt
                if limit &gt; 0 </span><span class="cov8" title="1">{
                        remaining = limit - len(result)
                }</span>
                // Query bucket in ascending order
                <span class="cov8" title="1">bucketAttestation, err := s.queryBucketAttestation(ctx, bucket, after+1, before-1, remaining, true)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">for _, ba := range bucketAttestation </span><span class="cov8" title="1">{
                        result = append(result, ba)
                        if limit &gt; 0 &amp;&amp; len(result) &gt;= limit </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">return result, nil</span>
}

// GetAttestationByAttestedAtBackward returns attestations within time range (after, before)
// (both exclusive), retrieved and ordered by AttestedAt timestamp in descending order.
//
// The function splits the time range into buckets and queries each bucket sequentially from latest to earliest.
// Results from all buckets are combined while maintaining the ordering.
//
// If limit &gt; 0, returns at most that many attestations. If limit &lt;= 0, returns all attestations
// in the time range.
func (s *BlobMetadataStore) GetAttestationByAttestedAtBackward(
        ctx context.Context,
        before uint64,
        after uint64,
        limit int,
) ([]*corev2.Attestation, error) <span class="cov8" title="1">{
        if after+1 &gt; before-1 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no time point in exclusive time range (%d, %d)", after, before)
        }</span>
        // Note: we traverse buckets in reverse order for backward query
        <span class="cov8" title="1">startBucket, endBucket := GetAttestedAtBucketIDRange(after, before)
        result := make([]*corev2.Attestation, 0)

        // Traverse buckets in reverse order
        for bucket := endBucket; bucket &gt;= startBucket; bucket-- </span><span class="cov8" title="1">{
                if limit &gt; 0 &amp;&amp; len(result) &gt;= limit </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">remaining := math.MaxInt
                if limit &gt; 0 </span><span class="cov8" title="1">{
                        remaining = limit - len(result)
                }</span>
                // Query bucket in descending order
                <span class="cov8" title="1">bucketAttestation, err := s.queryBucketAttestation(ctx, bucket, after+1, before-1, remaining, false)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">for _, ba := range bucketAttestation </span><span class="cov8" title="1">{
                        result = append(result, ba)
                        if limit &gt; 0 &amp;&amp; len(result) &gt;= limit </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">return result, nil</span>
}

// GetBlobMetadataByStatusPaginated returns all the metadata with the given status that were updated after the given cursor.
// It also returns a new cursor (last evaluated key) to be used for the next page
// even when there are no more results or there are no results at all.
// This cursor can be used to get new set of results when they become available.
// Therefore, it's possible to get an empty result from a request with exclusive start key returned from previous response.
func (s *BlobMetadataStore) GetBlobMetadataByStatusPaginated(
        ctx context.Context,
        status v2.BlobStatus,
        exclusiveStartKey *StatusIndexCursor,
        limit int32,
) ([]*v2.BlobMetadata, *StatusIndexCursor, error) <span class="cov8" title="1">{
        var cursor map[string]types.AttributeValue
        if exclusiveStartKey != nil </span><span class="cov8" title="1">{
                pk := blobKeyPrefix
                if exclusiveStartKey.BlobKey != nil &amp;&amp; len(exclusiveStartKey.BlobKey) == 32 </span><span class="cov8" title="1">{
                        pk = blobKeyPrefix + exclusiveStartKey.BlobKey.Hex()
                }</span>
                <span class="cov8" title="1">cursor = map[string]types.AttributeValue{
                        "PK": &amp;types.AttributeValueMemberS{
                                Value: pk,
                        },
                        "SK": &amp;types.AttributeValueMemberS{
                                Value: blobMetadataSK,
                        },
                        "UpdatedAt": &amp;types.AttributeValueMemberN{
                                Value: strconv.FormatUint(exclusiveStartKey.UpdatedAt, 10),
                        },
                        "BlobStatus": &amp;types.AttributeValueMemberN{
                                Value: strconv.Itoa(int(status)),
                        },
                }</span>
        } else<span class="cov8" title="1"> {
                cursor = map[string]types.AttributeValue{
                        "PK": &amp;types.AttributeValueMemberS{
                                Value: blobKeyPrefix,
                        },
                        "SK": &amp;types.AttributeValueMemberS{
                                Value: blobMetadataSK,
                        },
                        "UpdatedAt": &amp;types.AttributeValueMemberN{
                                Value: "0",
                        },
                        "BlobStatus": &amp;types.AttributeValueMemberN{
                                Value: strconv.Itoa(int(status)),
                        },
                }
        }</span>
        <span class="cov8" title="1">res, err := s.dynamoDBClient.QueryIndexWithPagination(ctx, s.tableName, StatusIndexName, "BlobStatus = :status", commondynamodb.ExpressionValues{
                ":status": &amp;types.AttributeValueMemberN{
                        Value: strconv.Itoa(int(status)),
                },
        }, limit, cursor, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // No results
        <span class="cov8" title="1">if len(res.Items) == 0 &amp;&amp; res.LastEvaluatedKey == nil </span><span class="cov8" title="1">{
                // return the same cursor
                return nil, exclusiveStartKey, nil
        }</span>

        <span class="cov8" title="1">metadata := make([]*v2.BlobMetadata, 0, len(res.Items))
        for _, item := range res.Items </span><span class="cov8" title="1">{
                m, err := UnmarshalBlobMetadata(item)
                // Skip invalid/corrupt items
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Errorf("failed to unmarshal blob metadata: %v", err)
                        continue</span>
                }
                <span class="cov8" title="1">metadata = append(metadata, m)</span>
        }

        <span class="cov8" title="1">lastEvaludatedKey := res.LastEvaluatedKey
        if lastEvaludatedKey == nil </span><span class="cov8" title="1">{
                return metadata, nil, nil
        }</span>

        <span class="cov8" title="1">newCursor := StatusIndexCursor{}
        err = attributevalue.UnmarshalMap(lastEvaludatedKey, &amp;newCursor)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">bk, err := UnmarshalBlobKey(lastEvaludatedKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">newCursor.BlobKey = &amp;bk

        return metadata, &amp;newCursor, nil</span>
}

// GetBlobMetadataCountByStatus returns the count of all the metadata with the given status
// Because this function scans the entire index, it should only be used for status with a limited number of items.
func (s *BlobMetadataStore) GetBlobMetadataCountByStatus(ctx context.Context, status v2.BlobStatus) (int32, error) <span class="cov8" title="1">{
        count, err := s.dynamoDBClient.QueryIndexCount(ctx, s.tableName, StatusIndexName, "BlobStatus = :status", commondynamodb.ExpressionValues{
                ":status": &amp;types.AttributeValueMemberN{
                        Value: strconv.Itoa(int(status)),
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return count, nil</span>
}

func (s *BlobMetadataStore) PutBlobCertificate(ctx context.Context, blobCert *corev2.BlobCertificate, fragmentInfo *encoding.FragmentInfo) error <span class="cov8" title="1">{
        item, err := MarshalBlobCertificate(blobCert, fragmentInfo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = s.dynamoDBClient.PutItemWithCondition(ctx, s.tableName, item, "attribute_not_exists(PK) AND attribute_not_exists(SK)", nil, nil)
        if errors.Is(err, commondynamodb.ErrConditionFailed) </span><span class="cov8" title="1">{
                return common.ErrAlreadyExists
        }</span>

        <span class="cov8" title="1">return err</span>
}

func (s *BlobMetadataStore) DeleteBlobCertificate(ctx context.Context, blobKey corev2.BlobKey) error <span class="cov0" title="0">{
        err := s.dynamoDBClient.DeleteItem(ctx, s.tableName, map[string]types.AttributeValue{
                "PK": &amp;types.AttributeValueMemberS{
                        Value: blobKeyPrefix + blobKey.Hex(),
                },
                "SK": &amp;types.AttributeValueMemberS{
                        Value: blobCertSK,
                },
        })

        return err
}</span>

func (s *BlobMetadataStore) GetBlobCertificate(ctx context.Context, blobKey corev2.BlobKey) (*corev2.BlobCertificate, *encoding.FragmentInfo, error) <span class="cov8" title="1">{
        item, err := s.dynamoDBClient.GetItem(ctx, s.tableName, map[string]types.AttributeValue{
                "PK": &amp;types.AttributeValueMemberS{
                        Value: blobKeyPrefix + blobKey.Hex(),
                },
                "SK": &amp;types.AttributeValueMemberS{
                        Value: blobCertSK,
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">if item == nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("%w: certificate not found for key %s", common.ErrMetadataNotFound, blobKey.Hex())
        }</span>

        <span class="cov8" title="1">cert, fragmentInfo, err := UnmarshalBlobCertificate(item)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">return cert, fragmentInfo, nil</span>
}

// GetBlobCertificates returns the certificates for the given blob keys
// Note: the returned certificates are NOT necessarily ordered by the order of the input blob keys
func (s *BlobMetadataStore) GetBlobCertificates(ctx context.Context, blobKeys []corev2.BlobKey) ([]*corev2.BlobCertificate, []*encoding.FragmentInfo, error) <span class="cov8" title="1">{
        keys := make([]map[string]types.AttributeValue, len(blobKeys))
        for i, blobKey := range blobKeys </span><span class="cov8" title="1">{
                keys[i] = map[string]types.AttributeValue{
                        "PK": &amp;types.AttributeValueMemberS{
                                Value: blobKeyPrefix + blobKey.Hex(),
                        },
                        "SK": &amp;types.AttributeValueMemberS{
                                Value: blobCertSK,
                        },
                }
        }</span>

        <span class="cov8" title="1">items, err := s.dynamoDBClient.GetItems(ctx, s.tableName, keys, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">certs := make([]*corev2.BlobCertificate, len(items))
        fragmentInfos := make([]*encoding.FragmentInfo, len(items))
        for i, item := range items </span><span class="cov8" title="1">{
                cert, fragmentInfo, err := UnmarshalBlobCertificate(item)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">certs[i] = cert
                fragmentInfos[i] = fragmentInfo</span>
        }

        <span class="cov8" title="1">return certs, fragmentInfos, nil</span>
}

func (s *BlobMetadataStore) PutDispersalRequest(ctx context.Context, req *corev2.DispersalRequest) error <span class="cov8" title="1">{
        item, err := MarshalDispersalRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = s.dynamoDBClient.PutItemWithCondition(ctx, s.tableName, item, "attribute_not_exists(PK) AND attribute_not_exists(SK)", nil, nil)
        if errors.Is(err, commondynamodb.ErrConditionFailed) </span><span class="cov8" title="1">{
                return common.ErrAlreadyExists
        }</span>

        <span class="cov8" title="1">return err</span>
}

func (s *BlobMetadataStore) GetDispersalRequest(ctx context.Context, batchHeaderHash [32]byte, operatorID core.OperatorID) (*corev2.DispersalRequest, error) <span class="cov8" title="1">{
        item, err := s.dynamoDBClient.GetItem(ctx, s.tableName, map[string]types.AttributeValue{
                "PK": &amp;types.AttributeValueMemberS{
                        Value: dispersalKeyPrefix + hex.EncodeToString(batchHeaderHash[:]),
                },
                "SK": &amp;types.AttributeValueMemberS{
                        Value: fmt.Sprintf("%s%s", dispersalRequestSKPrefix, operatorID.Hex()),
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if item == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: dispersal request not found for batch header hash %x and operator %s", common.ErrMetadataNotFound, batchHeaderHash, operatorID.Hex())
        }</span>

        <span class="cov8" title="1">req, err := UnmarshalDispersalRequest(item)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return req, nil</span>
}

// GetDispersalsByRespondedAt returns dispersals (in DispersalResponse, which has joined
// request and response together) to the given operator, within time range (start, end)
// (both exclusive), retrieved and ordered by RespondedAt timestamp in the specified order.
//
// If specified order is ascending (`ascending` is true), retrieve data from the oldest (`start`)
// to the newest (`end`); otherwise retrieve by the opposite direction.
//
// If limit &gt; 0, returns at most that many dispersals. If limit &lt;= 0, returns all results
// in the time range.
func (s *BlobMetadataStore) GetDispersalsByRespondedAt(
        ctx context.Context,
        operatorId core.OperatorID,
        start uint64,
        end uint64,
        limit int,
        ascending bool,
) ([]*corev2.DispersalResponse, error) <span class="cov8" title="1">{
        if start+1 &gt; end-1 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no time point in exclusive time range (%d, %d)", start, end)
        }</span>

        <span class="cov8" title="1">dispersals := make([]*corev2.DispersalResponse, 0)
        var lastEvaledKey map[string]types.AttributeValue
        adjustedStart, adjustedEnd := start+1, end-1

        // Iteratively fetch results until we get desired number of items or exhaust the
        // available data.
        // This needs to be processed in a loop because DynamoDb has a limit on the response
        // size of a query (1MB) and we may have more data than that.
        for </span><span class="cov8" title="1">{
                remaining := math.MaxInt
                if limit &gt; 0 </span><span class="cov8" title="1">{
                        remaining = limit - len(dispersals)
                }</span>
                <span class="cov8" title="1">res, err := s.dynamoDBClient.QueryIndexWithPagination(
                        ctx,
                        s.tableName,
                        OperatorResponseIndexName,
                        "OperatorID = :pk AND RespondedAt BETWEEN :start AND :end",
                        commondynamodb.ExpressionValues{
                                ":pk":    &amp;types.AttributeValueMemberS{Value: dispersalResponseSKPrefix + operatorId.Hex()},
                                ":start": &amp;types.AttributeValueMemberN{Value: strconv.FormatInt(int64(adjustedStart), 10)},
                                ":end":   &amp;types.AttributeValueMemberN{Value: strconv.FormatInt(int64(adjustedEnd), 10)},
                        },
                        int32(remaining),
                        lastEvaledKey,
                        ascending,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("query failed for operatorId %s with time range (%d, %d): %w", operatorId.Hex(), adjustedStart, adjustedEnd, err)
                }</span>

                // Collect results
                <span class="cov8" title="1">for _, item := range res.Items </span><span class="cov8" title="1">{
                        it, err := UnmarshalDispersalResponse(item)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to unmarshal DispersalResponse: %w", err)
                        }</span>
                        <span class="cov8" title="1">dispersals = append(dispersals, it)

                        // Desired number of items collected
                        if limit &gt; 0 &amp;&amp; len(dispersals) &gt;= limit </span><span class="cov8" title="1">{
                                return dispersals, nil
                        }</span>
                }

                // Exhausted all items already
                <span class="cov8" title="1">if res.LastEvaluatedKey == nil </span><span class="cov8" title="1">{
                        break</span>
                }
                // For next iteration
                <span class="cov0" title="0">lastEvaledKey = res.LastEvaluatedKey</span>
        }

        <span class="cov8" title="1">return dispersals, nil</span>
}

func (s *BlobMetadataStore) PutDispersalResponse(ctx context.Context, res *corev2.DispersalResponse) error <span class="cov8" title="1">{
        item, err := MarshalDispersalResponse(res)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = s.dynamoDBClient.PutItemWithCondition(ctx, s.tableName, item, "attribute_not_exists(PK) AND attribute_not_exists(SK)", nil, nil)
        if errors.Is(err, commondynamodb.ErrConditionFailed) </span><span class="cov8" title="1">{
                return common.ErrAlreadyExists
        }</span>

        <span class="cov8" title="1">return err</span>
}

func (s *BlobMetadataStore) GetDispersalResponse(ctx context.Context, batchHeaderHash [32]byte, operatorID core.OperatorID) (*corev2.DispersalResponse, error) <span class="cov8" title="1">{
        item, err := s.dynamoDBClient.GetItem(ctx, s.tableName, map[string]types.AttributeValue{
                "PK": &amp;types.AttributeValueMemberS{
                        Value: dispersalKeyPrefix + hex.EncodeToString(batchHeaderHash[:]),
                },
                "SK": &amp;types.AttributeValueMemberS{
                        Value: fmt.Sprintf("%s%s", dispersalResponseSKPrefix, operatorID.Hex()),
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if item == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: dispersal response not found for batch header hash %x and operator %s", common.ErrMetadataNotFound, batchHeaderHash, operatorID.Hex())
        }</span>

        <span class="cov8" title="1">res, err := UnmarshalDispersalResponse(item)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return res, nil</span>
}

func (s *BlobMetadataStore) GetDispersalResponses(ctx context.Context, batchHeaderHash [32]byte) ([]*corev2.DispersalResponse, error) <span class="cov8" title="1">{
        items, err := s.dynamoDBClient.Query(ctx, s.tableName, "PK = :pk AND begins_with(SK, :prefix)", commondynamodb.ExpressionValues{
                ":pk": &amp;types.AttributeValueMemberS{
                        Value: dispersalKeyPrefix + hex.EncodeToString(batchHeaderHash[:]),
                },
                ":prefix": &amp;types.AttributeValueMemberS{
                        Value: dispersalResponseSKPrefix,
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(items) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: dispersal responses not found for batch header hash %x", common.ErrMetadataNotFound, batchHeaderHash)
        }</span>

        <span class="cov8" title="1">responses := make([]*corev2.DispersalResponse, len(items))
        for i, item := range items </span><span class="cov8" title="1">{
                responses[i], err = UnmarshalDispersalResponse(item)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return responses, nil</span>
}

func (s *BlobMetadataStore) PutBatch(ctx context.Context, batch *corev2.Batch) error <span class="cov8" title="1">{
        item, err := MarshalBatch(batch)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = s.dynamoDBClient.PutItemWithCondition(ctx, s.tableName, item, "attribute_not_exists(PK) AND attribute_not_exists(SK)", nil, nil)
        if errors.Is(err, commondynamodb.ErrConditionFailed) </span><span class="cov0" title="0">{
                return common.ErrAlreadyExists
        }</span>

        <span class="cov8" title="1">return err</span>
}

func (s *BlobMetadataStore) GetBatch(ctx context.Context, batchHeaderHash [32]byte) (*corev2.Batch, error) <span class="cov8" title="1">{
        item, err := s.dynamoDBClient.GetItem(ctx, s.tableName, map[string]types.AttributeValue{
                "PK": &amp;types.AttributeValueMemberS{
                        Value: batchHeaderKeyPrefix + hex.EncodeToString(batchHeaderHash[:]),
                },
                "SK": &amp;types.AttributeValueMemberS{
                        Value: batchSK,
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if item == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: batch info not found for hash %x", common.ErrMetadataNotFound, batchHeaderHash)
        }</span>

        <span class="cov8" title="1">batch, err := UnmarshalBatch(item)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return batch, nil</span>
}

func (s *BlobMetadataStore) PutBatchHeader(ctx context.Context, batchHeader *corev2.BatchHeader) error <span class="cov8" title="1">{
        item, err := MarshalBatchHeader(batchHeader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = s.dynamoDBClient.PutItemWithCondition(ctx, s.tableName, item, "attribute_not_exists(PK) AND attribute_not_exists(SK)", nil, nil)
        if errors.Is(err, commondynamodb.ErrConditionFailed) </span><span class="cov8" title="1">{
                return common.ErrAlreadyExists
        }</span>

        <span class="cov8" title="1">return err</span>
}

func (s *BlobMetadataStore) DeleteBatchHeader(ctx context.Context, batchHeaderHash [32]byte) error <span class="cov0" title="0">{
        err := s.dynamoDBClient.DeleteItem(ctx, s.tableName, map[string]types.AttributeValue{
                "PK": &amp;types.AttributeValueMemberS{
                        Value: batchHeaderKeyPrefix + hex.EncodeToString(batchHeaderHash[:]),
                },
                "SK": &amp;types.AttributeValueMemberS{
                        Value: batchHeaderSK,
                },
        })

        return err
}</span>

func (s *BlobMetadataStore) GetBatchHeader(ctx context.Context, batchHeaderHash [32]byte) (*corev2.BatchHeader, error) <span class="cov8" title="1">{
        item, err := s.dynamoDBClient.GetItem(ctx, s.tableName, map[string]types.AttributeValue{
                "PK": &amp;types.AttributeValueMemberS{
                        Value: batchHeaderKeyPrefix + hex.EncodeToString(batchHeaderHash[:]),
                },
                "SK": &amp;types.AttributeValueMemberS{
                        Value: batchHeaderSK,
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if item == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: batch header not found for hash %x", common.ErrMetadataNotFound, batchHeaderHash)
        }</span>

        <span class="cov8" title="1">header, err := UnmarshalBatchHeader(item)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return header, nil</span>
}

func (s *BlobMetadataStore) PutAttestation(ctx context.Context, attestation *corev2.Attestation) error <span class="cov8" title="1">{
        item, err := MarshalAttestation(attestation)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Allow overwrite of existing attestation
        <span class="cov8" title="1">err = s.dynamoDBClient.PutItem(ctx, s.tableName, item)
        return err</span>
}

func (s *BlobMetadataStore) GetAttestation(ctx context.Context, batchHeaderHash [32]byte) (*corev2.Attestation, error) <span class="cov8" title="1">{
        input := &amp;dynamodb.GetItemInput{
                TableName: aws.String(s.tableName),
                Key: map[string]types.AttributeValue{
                        "PK": &amp;types.AttributeValueMemberS{
                                Value: batchHeaderKeyPrefix + hex.EncodeToString(batchHeaderHash[:]),
                        },
                        "SK": &amp;types.AttributeValueMemberS{
                                Value: attestationSK,
                        },
                },
                ConsistentRead: aws.Bool(true), // Use strongly consistent read to prevent race conditions
        }

        item, err := s.dynamoDBClient.GetItemWithInput(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if item == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: attestation not found for hash %x", common.ErrMetadataNotFound, batchHeaderHash)
        }</span>

        <span class="cov8" title="1">attestation, err := UnmarshalAttestation(item)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return attestation, nil</span>
}

func (s *BlobMetadataStore) PutBlobInclusionInfo(ctx context.Context, inclusionInfo *corev2.BlobInclusionInfo) error <span class="cov8" title="1">{
        item, err := MarshalBlobInclusionInfo(inclusionInfo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = s.dynamoDBClient.PutItemWithCondition(ctx, s.tableName, item, "attribute_not_exists(PK) AND attribute_not_exists(SK)", nil, nil)
        if errors.Is(err, commondynamodb.ErrConditionFailed) </span><span class="cov8" title="1">{
                return common.ErrAlreadyExists
        }</span>

        <span class="cov8" title="1">return err</span>
}

// PutBlobInclusionInfos puts multiple inclusion infos into the store
// It retries failed items up to 2 times
func (s *BlobMetadataStore) PutBlobInclusionInfos(ctx context.Context, inclusionInfos []*corev2.BlobInclusionInfo) error <span class="cov8" title="1">{
        items := make([]commondynamodb.Item, len(inclusionInfos))
        for i, info := range inclusionInfos </span><span class="cov8" title="1">{
                item, err := MarshalBlobInclusionInfo(info)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">items[i] = item</span>
        }

        <span class="cov8" title="1">numRetries := 3
        for i := 0; i &lt; numRetries; i++ </span><span class="cov8" title="1">{
                failedItems, err := s.dynamoDBClient.PutItems(ctx, s.tableName, items)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">if len(failedItems) &gt; 0 </span><span class="cov8" title="1">{
                        s.logger.Warnf("failed to put inclusion infos, retrying: %v", failedItems)
                        items = failedItems
                        time.Sleep(time.Duration(math.Pow(2, float64(i))) * time.Second) // Wait before retrying
                }</span> else<span class="cov8" title="1"> {
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *BlobMetadataStore) GetBlobInclusionInfo(ctx context.Context, blobKey corev2.BlobKey, batchHeaderHash [32]byte) (*corev2.BlobInclusionInfo, error) <span class="cov8" title="1">{
        bhh := hex.EncodeToString(batchHeaderHash[:])
        item, err := s.dynamoDBClient.GetItem(ctx, s.tableName, map[string]types.AttributeValue{
                "PK": &amp;types.AttributeValueMemberS{
                        Value: blobKeyPrefix + blobKey.Hex(),
                },
                "SK": &amp;types.AttributeValueMemberS{
                        Value: batchHeaderKeyPrefix + bhh,
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if item == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: inclusion info not found for key %s", common.ErrMetadataNotFound, blobKey.Hex())
        }</span>

        <span class="cov8" title="1">info, err := UnmarshalBlobInclusionInfo(item)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return info, nil</span>
}

func (s *BlobMetadataStore) GetBlobAttestationInfo(ctx context.Context, blobKey corev2.BlobKey) (*v2.BlobAttestationInfo, error) <span class="cov8" title="1">{
        blobInclusionInfos, err := s.GetBlobInclusionInfos(ctx, blobKey)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to get blob inclusion info for blob", "err", err, "blobKey", blobKey.Hex())
                return nil, api.NewErrorInternal(fmt.Sprintf("failed to get blob inclusion info: %s", err.Error()))
        }</span>

        <span class="cov8" title="1">if len(blobInclusionInfos) == 0 </span><span class="cov0" title="0">{
                s.logger.Error("no blob inclusion info found for blob", "blobKey", blobKey.Hex())
                return nil, api.NewErrorInternal("no blob inclusion info found")
        }</span>

        <span class="cov8" title="1">if len(blobInclusionInfos) &gt; 1 </span><span class="cov0" title="0">{
                s.logger.Warn("multiple inclusion info found for blob", "blobKey", blobKey.Hex())
        }</span>

        <span class="cov8" title="1">for _, inclusionInfo := range blobInclusionInfos </span><span class="cov8" title="1">{
                // get the signed batch from this inclusion info
                batchHeaderHash, err := inclusionInfo.BatchHeader.Hash()
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("failed to get batch header hash from blob inclusion info", "err", err, "blobKey", blobKey.Hex())
                        continue</span>
                }
                <span class="cov8" title="1">_, attestation, err := s.GetSignedBatch(ctx, batchHeaderHash)
                if err != nil </span><span class="cov8" title="1">{
                        s.logger.Error("failed to get signed batch", "err", err, "blobKey", blobKey.Hex())
                        continue</span>
                }

                <span class="cov8" title="1">return &amp;v2.BlobAttestationInfo{
                        InclusionInfo: inclusionInfo,
                        Attestation:   attestation,
                }, nil</span>
        }

        <span class="cov8" title="1">return nil, fmt.Errorf("no attestation info found for blobkey: %s", blobKey.Hex())</span>
}

func (s *BlobMetadataStore) GetBlobInclusionInfos(ctx context.Context, blobKey corev2.BlobKey) ([]*corev2.BlobInclusionInfo, error) <span class="cov8" title="1">{
        items, err := s.dynamoDBClient.Query(ctx, s.tableName, "PK = :pk AND begins_with(SK, :prefix)", commondynamodb.ExpressionValues{
                ":pk": &amp;types.AttributeValueMemberS{
                        Value: blobKeyPrefix + blobKey.Hex(),
                },
                ":prefix": &amp;types.AttributeValueMemberS{
                        Value: batchHeaderKeyPrefix,
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(items) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: inclusion info not found for key %s", common.ErrMetadataNotFound, blobKey.Hex())
        }</span>

        <span class="cov8" title="1">responses := make([]*corev2.BlobInclusionInfo, len(items))
        for i, item := range items </span><span class="cov8" title="1">{
                responses[i], err = UnmarshalBlobInclusionInfo(item)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal inclusion info: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return responses, nil</span>
}

func (s *BlobMetadataStore) GetSignedBatch(ctx context.Context, batchHeaderHash [32]byte) (*corev2.BatchHeader, *corev2.Attestation, error) <span class="cov8" title="1">{
        input := &amp;dynamodb.QueryInput{
                TableName:              aws.String(s.tableName),
                KeyConditionExpression: aws.String("PK = :pk"),
                ExpressionAttributeValues: map[string]types.AttributeValue{
                        ":pk": &amp;types.AttributeValueMemberS{
                                Value: batchHeaderKeyPrefix + hex.EncodeToString(batchHeaderHash[:]),
                        },
                },
                ConsistentRead: aws.Bool(true), // Use strongly consistent read to prevent race conditions
        }

        items, err := s.dynamoDBClient.QueryWithInput(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">if len(items) == 0 </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("%w: no records found for batch header hash %x", common.ErrMetadataNotFound, batchHeaderHash)
        }</span>

        <span class="cov8" title="1">var header *corev2.BatchHeader
        var attestation *corev2.Attestation
        for _, item := range items </span><span class="cov8" title="1">{
                sk, ok := item["SK"].(*types.AttributeValueMemberS)
                if !ok </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("expected *types.AttributeValueMemberS for SK, got %T", item["SK"])
                }</span>
                <span class="cov8" title="1">if strings.HasPrefix(sk.Value, batchHeaderSK) </span><span class="cov8" title="1">{
                        header, err = UnmarshalBatchHeader(item)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, fmt.Errorf("failed to unmarshal batch header: %w", err)
                        }</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(sk.Value, attestationSK) </span><span class="cov8" title="1">{
                        attestation, err = UnmarshalAttestation(item)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, fmt.Errorf("failed to unmarshal attestation: %w", err)
                        }</span>
                }
        }

        <span class="cov8" title="1">if header == nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("%w: batch header not found for hash %x", common.ErrMetadataNotFound, batchHeaderHash)
        }</span>

        <span class="cov8" title="1">if attestation == nil </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("%w: attestation not found for hash %x", common.ErrMetadataNotFound, batchHeaderHash)
        }</span>

        <span class="cov8" title="1">return header, attestation, nil</span>
}

func GenerateTableSchema(tableName string, readCapacityUnits int64, writeCapacityUnits int64) *dynamodb.CreateTableInput <span class="cov8" title="1">{
        return &amp;dynamodb.CreateTableInput{
                AttributeDefinitions: []types.AttributeDefinition{
                        // PK is the composite partition key
                        {
                                AttributeName: aws.String("PK"),
                                AttributeType: types.ScalarAttributeTypeS,
                        },
                        // SK is the composite sort key
                        {
                                AttributeName: aws.String("SK"),
                                AttributeType: types.ScalarAttributeTypeS,
                        },
                        {
                                AttributeName: aws.String("BlobStatus"),
                                AttributeType: types.ScalarAttributeTypeN,
                        },
                        {
                                AttributeName: aws.String("UpdatedAt"),
                                AttributeType: types.ScalarAttributeTypeN,
                        },
                        {
                                AttributeName: aws.String("OperatorID"),
                                AttributeType: types.ScalarAttributeTypeS,
                        },
                        {
                                AttributeName: aws.String("DispersedAt"),
                                AttributeType: types.ScalarAttributeTypeN,
                        },
                        {
                                AttributeName: aws.String("RespondedAt"),
                                AttributeType: types.ScalarAttributeTypeN,
                        },
                        {
                                AttributeName: aws.String("AccountID"),
                                AttributeType: types.ScalarAttributeTypeS,
                        },
                        {
                                AttributeName: aws.String("RequestedAt"),
                                AttributeType: types.ScalarAttributeTypeN,
                        },
                        {
                                AttributeName: aws.String("RequestedAtBucket"),
                                AttributeType: types.ScalarAttributeTypeS,
                        },
                        {
                                AttributeName: aws.String("RequestedAtBlobKey"),
                                AttributeType: types.ScalarAttributeTypeS,
                        },
                        {
                                AttributeName: aws.String("AttestedAtBucket"),
                                AttributeType: types.ScalarAttributeTypeS,
                        },
                        {
                                AttributeName: aws.String("AttestedAt"),
                                AttributeType: types.ScalarAttributeTypeN,
                        },
                },
                KeySchema: []types.KeySchemaElement{
                        {
                                AttributeName: aws.String("PK"),
                                KeyType:       types.KeyTypeHash,
                        },
                        {
                                AttributeName: aws.String("SK"),
                                KeyType:       types.KeyTypeRange,
                        },
                },
                TableName: aws.String(tableName),
                GlobalSecondaryIndexes: []types.GlobalSecondaryIndex{
                        {
                                IndexName: aws.String(StatusIndexName),
                                KeySchema: []types.KeySchemaElement{
                                        {
                                                AttributeName: aws.String("BlobStatus"),
                                                KeyType:       types.KeyTypeHash,
                                        },
                                        {
                                                AttributeName: aws.String("UpdatedAt"),
                                                KeyType:       types.KeyTypeRange,
                                        },
                                },
                                Projection: &amp;types.Projection{
                                        ProjectionType: types.ProjectionTypeAll,
                                },
                                ProvisionedThroughput: &amp;types.ProvisionedThroughput{
                                        ReadCapacityUnits:  aws.Int64(readCapacityUnits),
                                        WriteCapacityUnits: aws.Int64(writeCapacityUnits),
                                },
                        },
                        {
                                IndexName: aws.String(OperatorDispersalIndexName),
                                KeySchema: []types.KeySchemaElement{
                                        {
                                                AttributeName: aws.String("OperatorID"),
                                                KeyType:       types.KeyTypeHash,
                                        },
                                        {
                                                AttributeName: aws.String("DispersedAt"),
                                                KeyType:       types.KeyTypeRange,
                                        },
                                },
                                Projection: &amp;types.Projection{
                                        ProjectionType: types.ProjectionTypeAll,
                                },
                                ProvisionedThroughput: &amp;types.ProvisionedThroughput{
                                        ReadCapacityUnits:  aws.Int64(readCapacityUnits),
                                        WriteCapacityUnits: aws.Int64(writeCapacityUnits),
                                },
                        },
                        {
                                IndexName: aws.String(OperatorResponseIndexName),
                                KeySchema: []types.KeySchemaElement{
                                        {
                                                AttributeName: aws.String("OperatorID"),
                                                KeyType:       types.KeyTypeHash,
                                        },
                                        {
                                                AttributeName: aws.String("RespondedAt"),
                                                KeyType:       types.KeyTypeRange,
                                        },
                                },
                                Projection: &amp;types.Projection{
                                        ProjectionType: types.ProjectionTypeAll,
                                },
                                ProvisionedThroughput: &amp;types.ProvisionedThroughput{
                                        ReadCapacityUnits:  aws.Int64(readCapacityUnits),
                                        WriteCapacityUnits: aws.Int64(writeCapacityUnits),
                                },
                        },
                        {
                                IndexName: aws.String(AccountBlobIndexName),
                                KeySchema: []types.KeySchemaElement{
                                        {
                                                AttributeName: aws.String("AccountID"),
                                                KeyType:       types.KeyTypeHash,
                                        },
                                        {
                                                AttributeName: aws.String("RequestedAt"),
                                                KeyType:       types.KeyTypeRange,
                                        },
                                },
                                Projection: &amp;types.Projection{
                                        ProjectionType: types.ProjectionTypeAll,
                                },
                                ProvisionedThroughput: &amp;types.ProvisionedThroughput{
                                        ReadCapacityUnits:  aws.Int64(readCapacityUnits),
                                        WriteCapacityUnits: aws.Int64(writeCapacityUnits),
                                },
                        },
                        {
                                IndexName: aws.String(RequestedAtIndexName),
                                KeySchema: []types.KeySchemaElement{
                                        {
                                                AttributeName: aws.String("RequestedAtBucket"),
                                                KeyType:       types.KeyTypeHash,
                                        },
                                        {
                                                AttributeName: aws.String("RequestedAtBlobKey"),
                                                KeyType:       types.KeyTypeRange,
                                        },
                                },
                                Projection: &amp;types.Projection{
                                        ProjectionType: types.ProjectionTypeAll,
                                },
                                ProvisionedThroughput: &amp;types.ProvisionedThroughput{
                                        ReadCapacityUnits:  aws.Int64(readCapacityUnits),
                                        WriteCapacityUnits: aws.Int64(writeCapacityUnits),
                                },
                        },
                        {
                                IndexName: aws.String(AttestedAtIndexName),
                                KeySchema: []types.KeySchemaElement{
                                        {
                                                AttributeName: aws.String("AttestedAtBucket"),
                                                KeyType:       types.KeyTypeHash,
                                        },
                                        {
                                                AttributeName: aws.String("AttestedAt"),
                                                KeyType:       types.KeyTypeRange,
                                        },
                                },
                                Projection: &amp;types.Projection{
                                        ProjectionType: types.ProjectionTypeAll,
                                },
                                ProvisionedThroughput: &amp;types.ProvisionedThroughput{
                                        ReadCapacityUnits:  aws.Int64(readCapacityUnits),
                                        WriteCapacityUnits: aws.Int64(writeCapacityUnits),
                                },
                        },
                },
                ProvisionedThroughput: &amp;types.ProvisionedThroughput{
                        ReadCapacityUnits:  aws.Int64(readCapacityUnits),
                        WriteCapacityUnits: aws.Int64(writeCapacityUnits),
                },
        }
}</span>

func MarshalBlobMetadata(metadata *v2.BlobMetadata) (commondynamodb.Item, error) <span class="cov8" title="1">{
        fields, err := attributevalue.MarshalMap(metadata)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal blob metadata: %w", err)
        }</span>

        // Add PK and SK fields
        <span class="cov8" title="1">blobKey, err := metadata.BlobHeader.BlobKey()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">fields["PK"] = &amp;types.AttributeValueMemberS{Value: blobKeyPrefix + blobKey.Hex()}
        fields["SK"] = &amp;types.AttributeValueMemberS{Value: blobMetadataSK}
        fields["RequestedAtBucket"] = &amp;types.AttributeValueMemberS{Value: computeRequestedAtBucket(metadata.RequestedAt)}
        fields["RequestedAtBlobKey"] = &amp;types.AttributeValueMemberS{Value: encodeBlobFeedCursorKey(metadata.RequestedAt, &amp;blobKey)}
        fields["AccountID"] = &amp;types.AttributeValueMemberS{Value: metadata.BlobHeader.PaymentMetadata.AccountID.Hex()}

        return fields, nil</span>
}

func UnmarshalBlobKey(item commondynamodb.Item) (corev2.BlobKey, error) <span class="cov8" title="1">{
        type Blob struct {
                PK string
        }

        blob := Blob{}
        err := attributevalue.UnmarshalMap(item, &amp;blob)
        if err != nil </span><span class="cov0" title="0">{
                return corev2.BlobKey{}, err
        }</span>

        <span class="cov8" title="1">bk := strings.TrimPrefix(blob.PK, blobKeyPrefix)
        return corev2.HexToBlobKey(bk)</span>
}

func UnmarshalBlobMetadata(item commondynamodb.Item) (*v2.BlobMetadata, error) <span class="cov8" title="1">{
        metadata := v2.BlobMetadata{}
        err := attributevalue.UnmarshalMap(item, &amp;metadata)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;metadata, nil</span>
}

func MarshalBlobCertificate(blobCert *corev2.BlobCertificate, fragmentInfo *encoding.FragmentInfo) (commondynamodb.Item, error) <span class="cov8" title="1">{
        fields, err := attributevalue.MarshalMap(blobCert)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal blob certificate: %w", err)
        }</span>

        // merge fragment info
        <span class="cov8" title="1">fragmentInfoFields, err := attributevalue.MarshalMap(fragmentInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal fragment info: %w", err)
        }</span>
        <span class="cov8" title="1">for k, v := range fragmentInfoFields </span><span class="cov8" title="1">{
                fields[k] = v
        }</span>

        // Add PK and SK fields
        <span class="cov8" title="1">blobKey, err := blobCert.BlobHeader.BlobKey()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">fields["PK"] = &amp;types.AttributeValueMemberS{Value: blobKeyPrefix + blobKey.Hex()}
        fields["SK"] = &amp;types.AttributeValueMemberS{Value: blobCertSK}

        return fields, nil</span>
}

func UnmarshalBlobCertificate(item commondynamodb.Item) (*corev2.BlobCertificate, *encoding.FragmentInfo, error) <span class="cov8" title="1">{
        cert := corev2.BlobCertificate{}
        err := attributevalue.UnmarshalMap(item, &amp;cert)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to unmarshal blob certificate: %w", err)
        }</span>
        <span class="cov8" title="1">fragmentInfo := encoding.FragmentInfo{}
        err = attributevalue.UnmarshalMap(item, &amp;fragmentInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to unmarshal fragment info: %w", err)
        }</span>
        <span class="cov8" title="1">return &amp;cert, &amp;fragmentInfo, nil</span>
}

func UnmarshalBatchHeaderHash(item commondynamodb.Item) ([32]byte, error) <span class="cov0" title="0">{
        type Object struct {
                PK string
        }

        obj := Object{}
        err := attributevalue.UnmarshalMap(item, &amp;obj)
        if err != nil </span><span class="cov0" title="0">{
                return [32]byte{}, err
        }</span>

        <span class="cov0" title="0">root := strings.TrimPrefix(obj.PK, dispersalKeyPrefix)
        return hexToHash(root)</span>
}

func UnmarshalRequestedAtBlobKey(item commondynamodb.Item) (string, error) <span class="cov0" title="0">{
        type Object struct {
                RequestedAtBlobKey string
        }

        obj := Object{}
        err := attributevalue.UnmarshalMap(item, &amp;obj)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return obj.RequestedAtBlobKey, nil</span>
}

func UnmarshalAttestedAt(item commondynamodb.Item) (uint64, error) <span class="cov0" title="0">{
        type Object struct {
                AttestedAt uint64
        }

        obj := Object{}
        err := attributevalue.UnmarshalMap(item, &amp;obj)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return obj.AttestedAt, nil</span>
}

func UnmarshalOperatorID(item commondynamodb.Item) (*core.OperatorID, error) <span class="cov8" title="1">{
        type Object struct {
                OperatorID string
        }

        obj := Object{}
        err := attributevalue.UnmarshalMap(item, &amp;obj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Remove prefix if it exists
        <span class="cov8" title="1">operatorIDStr := obj.OperatorID
        if strings.HasPrefix(operatorIDStr, dispersalRequestSKPrefix) </span><span class="cov8" title="1">{
                operatorIDStr = strings.TrimPrefix(operatorIDStr, dispersalRequestSKPrefix)
        }</span> else<span class="cov8" title="1"> {
                operatorIDStr = strings.TrimPrefix(operatorIDStr, dispersalResponseSKPrefix)
        }</span>

        <span class="cov8" title="1">operatorID, err := core.OperatorIDFromHex(operatorIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;operatorID, nil</span>
}

func MarshalDispersalRequest(req *corev2.DispersalRequest) (commondynamodb.Item, error) <span class="cov8" title="1">{
        fields, err := attributevalue.MarshalMap(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal dispersal request: %w", err)
        }</span>

        <span class="cov8" title="1">batchHeaderHash, err := req.BatchHeader.Hash()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash batch header: %w", err)
        }</span>
        <span class="cov8" title="1">hashstr := hex.EncodeToString(batchHeaderHash[:])

        fields["PK"] = &amp;types.AttributeValueMemberS{Value: dispersalKeyPrefix + hashstr}
        fields["SK"] = &amp;types.AttributeValueMemberS{Value: fmt.Sprintf("%s%s", dispersalRequestSKPrefix, req.OperatorID.Hex())}
        fields["OperatorID"] = &amp;types.AttributeValueMemberS{Value: fmt.Sprintf("%s%s", dispersalRequestSKPrefix, req.OperatorID.Hex())}

        return fields, nil</span>
}

func UnmarshalDispersalRequest(item commondynamodb.Item) (*corev2.DispersalRequest, error) <span class="cov8" title="1">{
        req := corev2.DispersalRequest{}
        err := attributevalue.UnmarshalMap(item, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal dispersal request: %w", err)
        }</span>

        <span class="cov8" title="1">operatorID, err := UnmarshalOperatorID(item)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">req.OperatorID = *operatorID

        return &amp;req, nil</span>
}

func MarshalDispersalResponse(res *corev2.DispersalResponse) (commondynamodb.Item, error) <span class="cov8" title="1">{
        fields, err := attributevalue.MarshalMap(res)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal dispersal response: %w", err)
        }</span>

        <span class="cov8" title="1">batchHeaderHash, err := res.BatchHeader.Hash()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash batch header: %w", err)
        }</span>
        <span class="cov8" title="1">hashstr := hex.EncodeToString(batchHeaderHash[:])

        fields["PK"] = &amp;types.AttributeValueMemberS{Value: dispersalKeyPrefix + hashstr}
        fields["SK"] = &amp;types.AttributeValueMemberS{Value: fmt.Sprintf("%s%s", dispersalResponseSKPrefix, res.OperatorID.Hex())}
        fields["OperatorID"] = &amp;types.AttributeValueMemberS{Value: fmt.Sprintf("%s%s", dispersalResponseSKPrefix, res.OperatorID.Hex())}

        return fields, nil</span>
}

func UnmarshalDispersalResponse(item commondynamodb.Item) (*corev2.DispersalResponse, error) <span class="cov8" title="1">{
        res := corev2.DispersalResponse{}
        err := attributevalue.UnmarshalMap(item, &amp;res)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal dispersal response: %w", err)
        }</span>

        <span class="cov8" title="1">operatorID, err := UnmarshalOperatorID(item)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">res.OperatorID = *operatorID

        return &amp;res, nil</span>
}

func MarshalBatchHeader(batchHeader *corev2.BatchHeader) (commondynamodb.Item, error) <span class="cov8" title="1">{
        fields, err := attributevalue.MarshalMap(batchHeader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal batch header: %w", err)
        }</span>

        <span class="cov8" title="1">hash, err := batchHeader.Hash()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash batch header: %w", err)
        }</span>
        <span class="cov8" title="1">hashstr := hex.EncodeToString(hash[:])

        fields["PK"] = &amp;types.AttributeValueMemberS{Value: batchHeaderKeyPrefix + hashstr}
        fields["SK"] = &amp;types.AttributeValueMemberS{Value: batchHeaderSK}

        return fields, nil</span>
}

func UnmarshalBatchHeader(item commondynamodb.Item) (*corev2.BatchHeader, error) <span class="cov8" title="1">{
        header := corev2.BatchHeader{}
        err := attributevalue.UnmarshalMap(item, &amp;header)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal batch header: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;header, nil</span>
}

func MarshalBatch(batch *corev2.Batch) (commondynamodb.Item, error) <span class="cov8" title="1">{
        fields, err := attributevalue.MarshalMap(batch)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal batch: %w", err)
        }</span>

        <span class="cov8" title="1">hash, err := batch.BatchHeader.Hash()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash batch header: %w", err)
        }</span>
        <span class="cov8" title="1">hashstr := hex.EncodeToString(hash[:])

        fields["PK"] = &amp;types.AttributeValueMemberS{Value: batchHeaderKeyPrefix + hashstr}
        fields["SK"] = &amp;types.AttributeValueMemberS{Value: batchSK}

        return fields, nil</span>
}

func UnmarshalBatch(item commondynamodb.Item) (*corev2.Batch, error) <span class="cov8" title="1">{
        batch := corev2.Batch{}
        err := attributevalue.UnmarshalMap(item, &amp;batch)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal batch: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;batch, nil</span>
}

func MarshalBlobInclusionInfo(inclusionInfo *corev2.BlobInclusionInfo) (commondynamodb.Item, error) <span class="cov8" title="1">{
        fields, err := attributevalue.MarshalMap(inclusionInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal blob inclusion info: %w", err)
        }</span>

        <span class="cov8" title="1">bhh, err := inclusionInfo.BatchHeader.Hash()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash batch header: %w", err)
        }</span>
        <span class="cov8" title="1">hashstr := hex.EncodeToString(bhh[:])

        fields["PK"] = &amp;types.AttributeValueMemberS{Value: blobKeyPrefix + inclusionInfo.BlobKey.Hex()}
        fields["SK"] = &amp;types.AttributeValueMemberS{Value: batchHeaderKeyPrefix + hashstr}

        return fields, nil</span>
}

func UnmarshalBlobInclusionInfo(item commondynamodb.Item) (*corev2.BlobInclusionInfo, error) <span class="cov8" title="1">{
        inclusionInfo := corev2.BlobInclusionInfo{}
        err := attributevalue.UnmarshalMap(item, &amp;inclusionInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal blob inclusion info: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;inclusionInfo, nil</span>
}

func MarshalAttestation(attestation *corev2.Attestation) (commondynamodb.Item, error) <span class="cov8" title="1">{
        fields, err := attributevalue.MarshalMap(attestation)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal attestation: %w", err)
        }</span>

        <span class="cov8" title="1">hash, err := attestation.BatchHeader.Hash()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash batch header: %w", err)
        }</span>
        <span class="cov8" title="1">hashstr := hex.EncodeToString(hash[:])

        fields["PK"] = &amp;types.AttributeValueMemberS{Value: batchHeaderKeyPrefix + hashstr}
        fields["SK"] = &amp;types.AttributeValueMemberS{Value: attestationSK}
        fields["AttestedAtBucket"] = &amp;types.AttributeValueMemberS{Value: computeAttestedAtBucket(attestation.AttestedAt)}
        return fields, nil</span>
}

func UnmarshalAttestation(item commondynamodb.Item) (*corev2.Attestation, error) <span class="cov8" title="1">{
        attestation := corev2.Attestation{}
        err := attributevalue.UnmarshalMap(item, &amp;attestation)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal attestation: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;attestation, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package blobstore

import (
        "context"
        "encoding/binary"
        "encoding/hex"
        "fmt"
        "strings"
        "time"

        "github.com/Layr-Labs/eigenda/core"
        corev2 "github.com/Layr-Labs/eigenda/core/v2"
        v2 "github.com/Layr-Labs/eigenda/disperser/common/v2"
        "github.com/Layr-Labs/eigenda/encoding"
        gethcommon "github.com/ethereum/go-ethereum/common"
)

// BlobFeedCursor represents a position in the blob feed, which contains all blobs
// accepted by Disperser, ordered by (requestedAt, blobKey).
type BlobFeedCursor struct {
        RequestedAt uint64

        // The BlobKey can be nil, and a nil BlobKey is treated as equal to another nil BlobKey
        BlobKey *corev2.BlobKey
}

// StatusIndexCursor represents a cursor for paginated queries by blob status
type StatusIndexCursor struct {
        BlobKey   *corev2.BlobKey
        UpdatedAt uint64
}

// MetadataStore defines the interface for a blob metadata storage system
type MetadataStore interface {
        // Blob Metadata Operations
        // These methods manage the core blob metadata in the system
        CheckBlobExists(ctx context.Context, blobKey corev2.BlobKey) (bool, error)
        GetBlobMetadata(ctx context.Context, blobKey corev2.BlobKey) (*v2.BlobMetadata, error)
        PutBlobMetadata(ctx context.Context, blobMetadata *v2.BlobMetadata) error
        UpdateBlobStatus(ctx context.Context, key corev2.BlobKey, status v2.BlobStatus) error
        DeleteBlobMetadata(ctx context.Context, blobKey corev2.BlobKey) error // Only used in testing

        // Blob Query Operations
        // These methods provide various ways to query blobs based on different criteria
        GetBlobMetadataByAccountID(
                ctx context.Context,
                accountId gethcommon.Address,
                start uint64,
                end uint64,
                limit int,
                ascending bool,
        ) ([]*v2.BlobMetadata, error)
        GetBlobMetadataByStatus(ctx context.Context, status v2.BlobStatus, lastUpdatedAt uint64) ([]*v2.BlobMetadata, error)
        GetBlobMetadataByStatusPaginated(
                ctx context.Context,
                status v2.BlobStatus,
                exclusiveStartKey *StatusIndexCursor,
                limit int32,
        ) ([]*v2.BlobMetadata, *StatusIndexCursor, error)
        GetBlobMetadataCountByStatus(ctx context.Context, status v2.BlobStatus) (int32, error)

        // Blob Feed Operations
        // These methods support retrieving blobs in chronological order for feed-like functionality
        GetBlobMetadataByRequestedAtForward(
                ctx context.Context,
                after BlobFeedCursor,
                before BlobFeedCursor,
                limit int,
        ) ([]*v2.BlobMetadata, *BlobFeedCursor, error)
        GetBlobMetadataByRequestedAtBackward(
                ctx context.Context,
                before BlobFeedCursor,
                after BlobFeedCursor,
                limit int,
        ) ([]*v2.BlobMetadata, *BlobFeedCursor, error)

        // Blob Certificate Operations
        // These methods handle blob certificates which contain cryptographic proofs
        PutBlobCertificate(ctx context.Context, blobCert *corev2.BlobCertificate, fragmentInfo *encoding.FragmentInfo) error
        DeleteBlobCertificate(ctx context.Context, blobKey corev2.BlobKey) error
        GetBlobCertificate(ctx context.Context, blobKey corev2.BlobKey) (*corev2.BlobCertificate, *encoding.FragmentInfo, error)
        GetBlobCertificates(ctx context.Context, blobKeys []corev2.BlobKey) ([]*corev2.BlobCertificate, []*encoding.FragmentInfo, error)

        // Batch Operations
        // These methods manage batches of blobs that are processed together
        PutBatch(ctx context.Context, batch *corev2.Batch) error
        GetBatch(ctx context.Context, batchHeaderHash [32]byte) (*corev2.Batch, error)
        PutBatchHeader(ctx context.Context, batchHeader *corev2.BatchHeader) error
        DeleteBatchHeader(ctx context.Context, batchHeaderHash [32]byte) error
        GetBatchHeader(ctx context.Context, batchHeaderHash [32]byte) (*corev2.BatchHeader, error)

        // Dispersal Operations
        // These methods handle the distribution of blobs to operators
        PutDispersalRequest(ctx context.Context, req *corev2.DispersalRequest) error
        GetDispersalRequest(ctx context.Context, batchHeaderHash [32]byte, operatorID core.OperatorID) (*corev2.DispersalRequest, error)
        PutDispersalResponse(ctx context.Context, res *corev2.DispersalResponse) error
        GetDispersalResponse(ctx context.Context, batchHeaderHash [32]byte, operatorID core.OperatorID) (*corev2.DispersalResponse, error)
        GetDispersalResponses(ctx context.Context, batchHeaderHash [32]byte) ([]*corev2.DispersalResponse, error)
        GetDispersalsByRespondedAt(
                ctx context.Context,
                operatorId core.OperatorID,
                start uint64,
                end uint64,
                limit int,
                ascending bool,
        ) ([]*corev2.DispersalResponse, error)

        // Attestation Operations
        // These methods handle cryptographic attestations of batches
        PutAttestation(ctx context.Context, attestation *corev2.Attestation) error
        GetAttestation(ctx context.Context, batchHeaderHash [32]byte) (*corev2.Attestation, error)
        GetAttestationByAttestedAtForward(
                ctx context.Context,
                after uint64,
                before uint64,
                limit int,
        ) ([]*corev2.Attestation, error)
        GetAttestationByAttestedAtBackward(
                ctx context.Context,
                before uint64,
                after uint64,
                limit int,
        ) ([]*corev2.Attestation, error)

        // Blob Inclusion Operations
        // These methods handle information about blob inclusion in batches
        PutBlobInclusionInfo(ctx context.Context, inclusionInfo *corev2.BlobInclusionInfo) error
        PutBlobInclusionInfos(ctx context.Context, inclusionInfos []*corev2.BlobInclusionInfo) error
        GetBlobInclusionInfo(ctx context.Context, blobKey corev2.BlobKey, batchHeaderHash [32]byte) (*corev2.BlobInclusionInfo, error)
        GetBlobInclusionInfos(ctx context.Context, blobKey corev2.BlobKey) ([]*corev2.BlobInclusionInfo, error)
        GetBlobAttestationInfo(ctx context.Context, blobKey corev2.BlobKey) (*v2.BlobAttestationInfo, error)

        // Combined Operations
        // These methods provide convenient access to related data in a single call
        GetSignedBatch(ctx context.Context, batchHeaderHash [32]byte) (*corev2.BatchHeader, *corev2.Attestation, error)
}

// Equal returns true if the cursor is equal to the given &lt;requestedAt, blobKey&gt;
func (cursor *BlobFeedCursor) Equal(requestedAt uint64, blobKey *corev2.BlobKey) bool <span class="cov8" title="1">{
        if cursor.RequestedAt != requestedAt </span><span class="cov8" title="1">{
                return false
        }</span>

        // Both nil
        <span class="cov8" title="1">if cursor.BlobKey == nil &amp;&amp; blobKey == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        // One nil
        <span class="cov8" title="1">if cursor.BlobKey == nil || blobKey == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return cursor.BlobKey.Hex() == blobKey.Hex()</span>
}

// LessThan returns true if the current cursor is less than the other cursor
// in the ordering defined by (requestedAt, blobKey).
func (cursor *BlobFeedCursor) LessThan(other *BlobFeedCursor) bool <span class="cov8" title="1">{
        if other == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // First, compare the RequestedAt timestamps
        <span class="cov8" title="1">if cursor.RequestedAt != other.RequestedAt </span><span class="cov8" title="1">{
                return cursor.RequestedAt &lt; other.RequestedAt
        }</span>

        // If RequestedAt is the same, compare BlobKey
        <span class="cov8" title="1">if cursor.BlobKey != nil &amp;&amp; other.BlobKey != nil </span><span class="cov8" title="1">{
                return cursor.BlobKey.Hex() &lt; other.BlobKey.Hex()
        }</span>

        // Handle cases where BlobKey might be nil
        <span class="cov8" title="1">if cursor.BlobKey == nil &amp;&amp; other.BlobKey != nil </span><span class="cov8" title="1">{
                return true // cursor.BlobKey is nil, so it comes first
        }</span>
        <span class="cov8" title="1">if cursor.BlobKey != nil &amp;&amp; other.BlobKey == nil </span><span class="cov8" title="1">{
                return false // other.BlobKey is nil, so "other" comes first
        }</span>

        // If both RequestedAt and BlobKey are equal, return false (because they are equal)
        <span class="cov8" title="1">return false</span>
}

// ToCursorKey encodes the cursor into a string that preserves ordering.
// For any two cursors A and B:
// - A &lt; B if and only if A.ToCursorKey() &lt; B.ToCursorKey()
// - A == B if and only if A.ToCursorKey() == B.ToCursorKey()
func (cursor *BlobFeedCursor) ToCursorKey() string <span class="cov8" title="1">{
        return encodeBlobFeedCursorKey(cursor.RequestedAt, cursor.BlobKey)
}</span>

// FromCursorKey decodes the cursor key string back to the cursor.
func (cursor *BlobFeedCursor) FromCursorKey(encoded string) (*BlobFeedCursor, error) <span class="cov8" title="1">{
        requestedAt, blobKey, err := decodeBlobFeedCursorKey(encoded)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;BlobFeedCursor{
                RequestedAt: requestedAt,
                BlobKey:     blobKey,
        }, nil</span>
}

// GetRequestedAtBucketIDRange returns the adjusted start and end bucket IDs based on
// the allowed time range for blobs.
func GetRequestedAtBucketIDRange(startTime, endTime uint64) (uint64, uint64) <span class="cov8" title="1">{
        now := uint64(time.Now().UnixNano())
        oldestAllowed := now - maxBlobAgeInNano

        startBucket := computeBucketID(startTime, requestedAtBucketSizeNano)
        if startTime &lt; oldestAllowed </span><span class="cov8" title="1">{
                startBucket = computeBucketID(oldestAllowed, requestedAtBucketSizeNano)
        }</span>

        <span class="cov8" title="1">endBucket := computeBucketID(endTime, requestedAtBucketSizeNano)
        if endTime &gt; now </span><span class="cov8" title="1">{
                endBucket = computeBucketID(now, requestedAtBucketSizeNano)
        }</span>

        <span class="cov8" title="1">return startBucket, endBucket</span>
}

// GetAttestedAtBucketIDRange returns the adjusted start and end bucket IDs based on
// the allowed time range for blobs.
func GetAttestedAtBucketIDRange(startTime, endTime uint64) (uint64, uint64) <span class="cov8" title="1">{
        now := uint64(time.Now().UnixNano())
        oldestAllowed := now - maxBlobAgeInNano

        startBucket := computeBucketID(startTime, attestedAtBucketSizeNano)
        if startTime &lt; oldestAllowed </span><span class="cov8" title="1">{
                startBucket = computeBucketID(oldestAllowed, attestedAtBucketSizeNano)
        }</span>

        <span class="cov8" title="1">endBucket := computeBucketID(endTime, attestedAtBucketSizeNano)
        if endTime &gt; now </span><span class="cov8" title="1">{
                endBucket = computeBucketID(now, attestedAtBucketSizeNano)
        }</span>

        <span class="cov8" title="1">return startBucket, endBucket</span>
}

// encodeBlobFeedCursorKey encodes &lt;requestedAt, blobKey&gt; into string which
// preserves the order.
func encodeBlobFeedCursorKey(requestedAt uint64, blobKey *corev2.BlobKey) string <span class="cov8" title="1">{
        result := make([]byte, 40) // 8 bytes for timestamp + 32 bytes for blobKey

        // Write timestamp
        binary.BigEndian.PutUint64(result[:8], requestedAt)

        if blobKey != nil </span><span class="cov8" title="1">{
                copy(result[8:], blobKey[:])
        }</span>
        // Use hex encoding to preserve byte ordering
        <span class="cov8" title="1">return hex.EncodeToString(result)</span>
}

// decodeBlobFeedCursorKey decodes the cursor key back to &lt;requestedAt, blobKey&gt;.
func decodeBlobFeedCursorKey(encoded string) (uint64, *corev2.BlobKey, error) <span class="cov8" title="1">{
        // Decode hex string
        bytes, err := hex.DecodeString(encoded)
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, fmt.Errorf("invalid hex encoding: %w", err)
        }</span>

        // Check length
        <span class="cov8" title="1">if len(bytes) != 40 </span><span class="cov0" title="0">{ // 8 bytes timestamp + 32 bytes blobKey
                return 0, nil, fmt.Errorf("invalid length: expected 40 bytes, got %d", len(bytes))
        }</span>

        // Get timestamp
        <span class="cov8" title="1">requestedAt := binary.BigEndian.Uint64(bytes[:8])

        // Check if the remaining bytes are all zeros
        allZeros := true
        for i := 8; i &lt; len(bytes); i++ </span><span class="cov8" title="1">{
                if bytes[i] != 0 </span><span class="cov8" title="1">{
                        allZeros = false
                        break</span>
                }
        }

        <span class="cov8" title="1">if allZeros </span><span class="cov8" title="1">{
                return requestedAt, nil, nil
        }</span>
        <span class="cov8" title="1">var bk corev2.BlobKey
        copy(bk[:], bytes[8:])
        return requestedAt, &amp;bk, nil</span>
}

func hexToHash(h string) ([32]byte, error) <span class="cov0" title="0">{
        s := strings.TrimPrefix(h, "0x")
        s = strings.TrimPrefix(s, "0X")
        b, err := hex.DecodeString(s)
        if err != nil </span><span class="cov0" title="0">{
                return [32]byte{}, err
        }</span>
        <span class="cov0" title="0">return [32]byte(b), nil</span>
}

// computeBucketID maps a given timestamp to a time bucket.
// Note each bucket represents a time range [start, end) (i.e. inclusive start, exclusive end).
func computeBucketID(timestamp, bucketSizeNano uint64) uint64 <span class="cov8" title="1">{
        return timestamp / bucketSizeNano
}</span>

func computeRequestedAtBucket(requestedAt uint64) string <span class="cov8" title="1">{
        id := computeBucketID(requestedAt, requestedAtBucketSizeNano)
        return fmt.Sprintf("%d", id)
}</span>

func computeAttestedAtBucket(attestedAt uint64) string <span class="cov8" title="1">{
        id := computeBucketID(attestedAt, attestedAtBucketSizeNano)
        return fmt.Sprintf("%d", id)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package blobstore

import (
        "context"
        "database/sql"
        "encoding/json"
        "errors"
        "fmt"
        "math"
        "strings"
        "time"

        "github.com/Layr-Labs/eigenda/api"
        "github.com/Layr-Labs/eigenda/core"
        corev2 "github.com/Layr-Labs/eigenda/core/v2"
        "github.com/Layr-Labs/eigenda/disperser/common"
        dispersercommon "github.com/Layr-Labs/eigenda/disperser/common"
        v2 "github.com/Layr-Labs/eigenda/disperser/common/v2"
        "github.com/Layr-Labs/eigenda/encoding"
        "github.com/Layr-Labs/eigensdk-go/logging"
        gethcommon "github.com/ethereum/go-ethereum/common"
        _ "github.com/jackc/pgx/v5/stdlib" // pgx driver
        "github.com/jmoiron/sqlx"
)

// Ensure PostgresBlobMetadataStore implements MetadataStore
var _ MetadataStore = (*PostgresBlobMetadataStore)(nil)

// PostgresBlobMetadataStore is a blob metadata storage backed by PostgreSQL
type PostgresBlobMetadataStore struct {
        db     *sqlx.DB
        logger logging.Logger
}

// GetDB returns the database connection for testing purposes
func (s *PostgresBlobMetadataStore) GetDB() *sqlx.DB <span class="cov0" title="0">{
        return s.db
}</span>

// PostgreSQLConfig contains configuration for PostgreSQL connection
type PostgreSQLConfig struct {
        Host     string
        Port     int
        Username string
        Password string
        Database string
        SSLMode  string
}

// NewPostgresBlobMetadataStore creates a new PostgresBlobMetadataStore instance
func NewPostgresBlobMetadataStore(config PostgreSQLConfig, logger logging.Logger) (*PostgresBlobMetadataStore, error) <span class="cov0" title="0">{
        connStr := fmt.Sprintf(
                "host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                config.Host, config.Port, config.Username, config.Password, config.Database, config.SSLMode,
        )

        db, err := sqlx.Connect("pgx", connStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to PostgreSQL: %w", err)
        }</span>

        // Configure connection pool
        <span class="cov0" title="0">db.SetMaxOpenConns(25)
        db.SetMaxIdleConns(5)
        db.SetConnMaxLifetime(5 * time.Minute)

        store := &amp;PostgresBlobMetadataStore{
                db:     db,
                logger: logger.With("component", "postgresMetadataStore"),
        }

        // Initialize the database tables
        if err := store.initTables(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize tables: %w", err)
        }</span>

        <span class="cov0" title="0">return store, nil</span>
}

// initTables creates the necessary tables if they don't exist
func (s *PostgresBlobMetadataStore) initTables() error <span class="cov0" title="0">{
        // Create tables for blob metadata
        _, err := s.db.Exec(`
                CREATE TABLE IF NOT EXISTS blob_metadata (
                        blob_key BYTEA PRIMARY KEY,
                        blob_header JSONB NOT NULL,
                        requested_at BIGINT NOT NULL,
                        requested_at_bucket VARCHAR(64) NOT NULL,
                        requested_at_blob_key VARCHAR(128) NOT NULL,
                        blob_status INTEGER NOT NULL,
                        updated_at BIGINT NOT NULL,
                        account_id VARCHAR(42) NOT NULL
                );

                CREATE INDEX IF NOT EXISTS idx_blob_metadata_blob_status_updated_at ON blob_metadata (blob_status, updated_at);
                CREATE INDEX IF NOT EXISTS idx_blob_metadata_account_id_requested_at ON blob_metadata (account_id, requested_at);
                CREATE INDEX IF NOT EXISTS idx_blob_metadata_requested_at_bucket_key ON blob_metadata (requested_at_bucket, requested_at_blob_key);
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create blob_metadata table: %w", err)
        }</span>

        // Create tables for blob certificates
        <span class="cov0" title="0">_, err = s.db.Exec(`
                CREATE TABLE IF NOT EXISTS blob_certificates (
                        blob_key BYTEA PRIMARY KEY,
                        blob_certificate JSONB NOT NULL,
                        fragment_info JSONB NOT NULL
                );
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create blob_certificates table: %w", err)
        }</span>

        // Create tables for batch headers
        <span class="cov0" title="0">_, err = s.db.Exec(`
                CREATE TABLE IF NOT EXISTS batch_headers (
                        batch_header_hash BYTEA PRIMARY KEY,
                        batch_header JSONB NOT NULL
                );
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create batch_headers table: %w", err)
        }</span>

        // Create tables for batches
        <span class="cov0" title="0">_, err = s.db.Exec(`
                CREATE TABLE IF NOT EXISTS batches (
                        batch_header_hash BYTEA PRIMARY KEY,
                        batch_info JSONB NOT NULL
                );
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create batches table: %w", err)
        }</span>

        // Create tables for dispersal requests
        <span class="cov0" title="0">_, err = s.db.Exec(`
                CREATE TABLE IF NOT EXISTS dispersal_requests (
                        batch_header_hash BYTEA NOT NULL,
                        operator_id BYTEA NOT NULL,
                        dispersal_request JSONB NOT NULL,
                        dispersed_at BIGINT NOT NULL,
                        PRIMARY KEY (batch_header_hash, operator_id)
                );

                CREATE INDEX IF NOT EXISTS idx_dispersal_requests_operator_dispersed_at ON dispersal_requests (operator_id, dispersed_at);
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create dispersal_requests table: %w", err)
        }</span>

        // Create tables for dispersal responses
        <span class="cov0" title="0">_, err = s.db.Exec(`
                CREATE TABLE IF NOT EXISTS dispersal_responses (
                        batch_header_hash BYTEA NOT NULL,
                        operator_id BYTEA NOT NULL,
                        dispersal_response JSONB NOT NULL,
                        responded_at BIGINT NOT NULL,
                        PRIMARY KEY (batch_header_hash, operator_id)
                );

                CREATE INDEX IF NOT EXISTS idx_dispersal_responses_operator_responded_at ON dispersal_responses (operator_id, responded_at);
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create dispersal_responses table: %w", err)
        }</span>

        // Create tables for attestations
        <span class="cov0" title="0">_, err = s.db.Exec(`
                CREATE TABLE IF NOT EXISTS attestations (
                        batch_header_hash BYTEA PRIMARY KEY,
                        attestation JSONB NOT NULL,
                        attested_at BIGINT NOT NULL,
                        attested_at_bucket VARCHAR(64) NOT NULL
                );

                CREATE INDEX IF NOT EXISTS idx_attestations_attested_at_bucket_attested_at ON attestations (attested_at_bucket, attested_at);
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create attestations table: %w", err)
        }</span>

        // Create tables for blob inclusion info
        <span class="cov0" title="0">_, err = s.db.Exec(`
                CREATE TABLE IF NOT EXISTS blob_inclusion_info (
                        blob_key BYTEA NOT NULL,
                        batch_header_hash BYTEA NOT NULL,
                        inclusion_info JSONB NOT NULL,
                        PRIMARY KEY (blob_key, batch_header_hash)
                );
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create blob_inclusion_info table: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CheckBlobExists checks if a blob exists without fetching the entire metadata
func (s *PostgresBlobMetadataStore) CheckBlobExists(ctx context.Context, blobKey corev2.BlobKey) (bool, error) <span class="cov0" title="0">{
        var exists bool
        query := "SELECT EXISTS(SELECT 1 FROM blob_metadata WHERE blob_key = $1)"
        err := s.db.GetContext(ctx, &amp;exists, query, blobKey[:])
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check blob existence: %w", err)
        }</span>
        <span class="cov0" title="0">return exists, nil</span>
}

// GetBlobMetadata retrieves blob metadata by its key
func (s *PostgresBlobMetadataStore) GetBlobMetadata(ctx context.Context, blobKey corev2.BlobKey) (*v2.BlobMetadata, error) <span class="cov0" title="0">{
        var result struct {
                BlobHeader  []byte `db:"blob_header"`
                RequestedAt uint64 `db:"requested_at"`
                BlobStatus  int    `db:"blob_status"`
                UpdatedAt   uint64 `db:"updated_at"`
        }

        query := "SELECT blob_header, requested_at, blob_status, updated_at FROM blob_metadata WHERE blob_key = $1"
        err := s.db.GetContext(ctx, &amp;result, query, blobKey[:])
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: metadata not found for key %s", common.ErrMetadataNotFound, blobKey.Hex())
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get blob metadata: %w", err)</span>
        }

        <span class="cov0" title="0">metadata := &amp;v2.BlobMetadata{
                RequestedAt: result.RequestedAt,
                BlobStatus:  v2.BlobStatus(result.BlobStatus),
                UpdatedAt:   result.UpdatedAt,
        }

        // Unmarshal BlobHeader
        err = json.Unmarshal(result.BlobHeader, &amp;metadata.BlobHeader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal blob header: %w", err)
        }</span>

        <span class="cov0" title="0">return metadata, nil</span>
}

// PutBlobMetadata stores blob metadata
func (s *PostgresBlobMetadataStore) PutBlobMetadata(ctx context.Context, blobMetadata *v2.BlobMetadata) error <span class="cov0" title="0">{
        s.logger.Debug("store put blob metadata", "blobMetadata", blobMetadata)

        // Marshal BlobHeader to JSON
        blobHeaderJSON, err := json.Marshal(blobMetadata.BlobHeader)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal blob header: %w", err)
        }</span>

        // Get blob key
        <span class="cov0" title="0">blobKey, err := blobMetadata.BlobHeader.BlobKey()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get blob key: %w", err)
        }</span>

        // Generate additional fields
        <span class="cov0" title="0">requestedAtBucket := computeRequestedAtBucket(blobMetadata.RequestedAt)
        requestedAtBlobKey := encodeBlobFeedCursorKey(blobMetadata.RequestedAt, &amp;blobKey)

        // Insert into database
        query := `
                INSERT INTO blob_metadata (
                        blob_key, blob_header, requested_at, requested_at_bucket, 
                        requested_at_blob_key, blob_status, updated_at, account_id
                ) VALUES (
                        $1, $2, $3, $4, $5, $6, $7, $8
                ) ON CONFLICT DO NOTHING
        `
        res, err := s.db.ExecContext(
                ctx, query,
                blobKey[:], blobHeaderJSON, blobMetadata.RequestedAt, requestedAtBucket,
                requestedAtBlobKey, int(blobMetadata.BlobStatus), blobMetadata.UpdatedAt,
                blobMetadata.BlobHeader.PaymentMetadata.AccountID.Hex(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert blob metadata: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return dispersercommon.ErrAlreadyExists
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateBlobStatus updates the status of a blob
func (s *PostgresBlobMetadataStore) UpdateBlobStatus(ctx context.Context, blobKey corev2.BlobKey, status v2.BlobStatus) error <span class="cov0" title="0">{
        validStatuses := statusUpdatePrecondition[status]
        if len(validStatuses) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: invalid status transition to %s", ErrInvalidStateTransition, status.String())
        }</span>

        // Build the WHERE condition for valid statuses
        <span class="cov0" title="0">var placeholders []string
        var args []interface{}
        args = append(args, blobKey[:]) // $1 for the blob key

        for i, validStatus := range validStatuses </span><span class="cov0" title="0">{
                placeholders = append(placeholders, fmt.Sprintf("$%d", i+2))
                args = append(args, int(validStatus))
        }</span>
        <span class="cov0" title="0">statusPlaceholders := strings.Join(placeholders, ", ")

        // Current time for updated_at
        now := time.Now().UnixNano()

        // Update the blob status
        query := fmt.Sprintf(`
                UPDATE blob_metadata 
                SET blob_status = $%d, updated_at = $%d 
                WHERE blob_key = $1 AND blob_status IN (%s)
        `, len(args)+1, len(args)+2, statusPlaceholders)

        args = append(args, int(status), now)

        res, err := s.db.ExecContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update blob status: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                // Get current blob status to provide better error messages
                blob, err := s.GetBlobMetadata(ctx, blobKey)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get blob metadata for key %s: %v", blobKey.Hex(), err)
                }</span>

                <span class="cov0" title="0">if blob.BlobStatus == status </span><span class="cov0" title="0">{
                        return fmt.Errorf("%w: blob already in status %s", dispersercommon.ErrAlreadyExists, status.String())
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("%w: invalid status transition from %s to %s", ErrInvalidStateTransition, blob.BlobStatus.String(), status.String())</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// DeleteBlobMetadata deletes blob metadata by its key (only used in testing)
func (s *PostgresBlobMetadataStore) DeleteBlobMetadata(ctx context.Context, blobKey corev2.BlobKey) error <span class="cov0" title="0">{
        query := "DELETE FROM blob_metadata WHERE blob_key = $1"
        _, err := s.db.ExecContext(ctx, query, blobKey[:])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete blob metadata: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetBlobMetadataByAccountID retrieves blob metadata by account ID within a time range
func (s *PostgresBlobMetadataStore) GetBlobMetadataByAccountID(
        ctx context.Context,
        accountId gethcommon.Address,
        start uint64,
        end uint64,
        limit int,
        ascending bool,
) ([]*v2.BlobMetadata, error) <span class="cov0" title="0">{
        if start+1 &gt; end-1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no time point in exclusive time range (%d, %d)", start, end)
        }</span>

        // Adjust time range to be exclusive
        <span class="cov0" title="0">adjustedStart, adjustedEnd := start+1, end-1

        // Order by clause based on ascending flag
        orderBy := "ASC"
        if !ascending </span><span class="cov0" title="0">{
                orderBy = "DESC"
        }</span>

        // Limit clause
        <span class="cov0" title="0">limitClause := ""
        if limit &gt; 0 </span><span class="cov0" title="0">{
                limitClause = fmt.Sprintf("LIMIT %d", limit)
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT blob_key, blob_header, requested_at, blob_status, updated_at
                FROM blob_metadata
                WHERE account_id = $1 AND requested_at BETWEEN $2 AND $3
                ORDER BY requested_at %s
                %s
        `, orderBy, limitClause)

        rows, err := s.db.QueryxContext(ctx, query, accountId.Hex(), adjustedStart, adjustedEnd)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query blob metadata by account ID: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var results []*v2.BlobMetadata
        for rows.Next() </span><span class="cov0" title="0">{
                var result struct {
                        BlobKey     []byte `db:"blob_key"`
                        BlobHeader  []byte `db:"blob_header"`
                        RequestedAt uint64 `db:"requested_at"`
                        BlobStatus  int    `db:"blob_status"`
                        UpdatedAt   uint64 `db:"updated_at"`
                }

                if err := rows.StructScan(&amp;result); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan blob metadata: %w", err)
                }</span>

                <span class="cov0" title="0">metadata := &amp;v2.BlobMetadata{
                        RequestedAt: result.RequestedAt,
                        BlobStatus:  v2.BlobStatus(result.BlobStatus),
                        UpdatedAt:   result.UpdatedAt,
                }

                // Unmarshal BlobHeader
                err = json.Unmarshal(result.BlobHeader, &amp;metadata.BlobHeader)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal blob header: %w", err)
                }</span>

                <span class="cov0" title="0">results = append(results, metadata)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating through rows: %w", err)
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

// GetBlobMetadataByStatus retrieves blob metadata by status updated after a specific timestamp
func (s *PostgresBlobMetadataStore) GetBlobMetadataByStatus(ctx context.Context, status v2.BlobStatus, lastUpdatedAt uint64) ([]*v2.BlobMetadata, error) <span class="cov0" title="0">{
        query := `
                SELECT blob_key, blob_header, requested_at, blob_status, updated_at
                FROM blob_metadata
                WHERE blob_status = $1 AND updated_at &gt; $2
                ORDER BY updated_at ASC
        `

        rows, err := s.db.QueryxContext(ctx, query, int(status), lastUpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query blob metadata by status: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var results []*v2.BlobMetadata
        for rows.Next() </span><span class="cov0" title="0">{
                var result struct {
                        BlobKey     []byte `db:"blob_key"`
                        BlobHeader  []byte `db:"blob_header"`
                        RequestedAt uint64 `db:"requested_at"`
                        BlobStatus  int    `db:"blob_status"`
                        UpdatedAt   uint64 `db:"updated_at"`
                }

                if err := rows.StructScan(&amp;result); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan blob metadata: %w", err)
                }</span>

                <span class="cov0" title="0">metadata := &amp;v2.BlobMetadata{
                        RequestedAt: result.RequestedAt,
                        BlobStatus:  v2.BlobStatus(result.BlobStatus),
                        UpdatedAt:   result.UpdatedAt,
                }

                // Unmarshal BlobHeader
                err = json.Unmarshal(result.BlobHeader, &amp;metadata.BlobHeader)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal blob header: %w", err)
                }</span>

                <span class="cov0" title="0">results = append(results, metadata)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating through rows: %w", err)
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

// GetBlobMetadataByStatusPaginated retrieves blob metadata by status with pagination
func (s *PostgresBlobMetadataStore) GetBlobMetadataByStatusPaginated(
        ctx context.Context,
        status v2.BlobStatus,
        exclusiveStartKey *StatusIndexCursor,
        limit int32,
) ([]*v2.BlobMetadata, *StatusIndexCursor, error) <span class="cov0" title="0">{
        var query string
        var args []interface{}

        if exclusiveStartKey != nil &amp;&amp; exclusiveStartKey.BlobKey != nil </span><span class="cov0" title="0">{
                // Continue from the previous cursor
                query = `
                        SELECT blob_key, blob_header, requested_at, blob_status, updated_at
                        FROM blob_metadata
                        WHERE blob_status = $1 AND 
                                  (updated_at &gt; $2 OR (updated_at = $2 AND blob_key &gt; $3))
                        ORDER BY updated_at ASC, blob_key ASC
                        LIMIT $4
                `
                args = append(args, int(status), exclusiveStartKey.UpdatedAt, exclusiveStartKey.BlobKey[:], limit)
        }</span> else<span class="cov0" title="0"> {
                // Start from the beginning
                query = `
                        SELECT blob_key, blob_header, requested_at, blob_status, updated_at
                        FROM blob_metadata
                        WHERE blob_status = $1
                        ORDER BY updated_at ASC, blob_key ASC
                        LIMIT $2
                `
                args = append(args, int(status), limit)
        }</span>

        <span class="cov0" title="0">rows, err := s.db.QueryxContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to query blob metadata by status paginated: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var results []*v2.BlobMetadata
        var lastBlobKey []byte
        var lastUpdatedAt uint64

        for rows.Next() </span><span class="cov0" title="0">{
                var result struct {
                        BlobKey     []byte `db:"blob_key"`
                        BlobHeader  []byte `db:"blob_header"`
                        RequestedAt uint64 `db:"requested_at"`
                        BlobStatus  int    `db:"blob_status"`
                        UpdatedAt   uint64 `db:"updated_at"`
                }

                if err := rows.StructScan(&amp;result); err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("failed to scan blob metadata: %w", err)
                }</span>

                <span class="cov0" title="0">lastBlobKey = result.BlobKey
                lastUpdatedAt = result.UpdatedAt

                metadata := &amp;v2.BlobMetadata{
                        RequestedAt: result.RequestedAt,
                        BlobStatus:  v2.BlobStatus(result.BlobStatus),
                        UpdatedAt:   result.UpdatedAt,
                }

                // Unmarshal BlobHeader
                err = json.Unmarshal(result.BlobHeader, &amp;metadata.BlobHeader)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("failed to unmarshal blob header: %w", err)
                }</span>

                <span class="cov0" title="0">results = append(results, metadata)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("error iterating through rows: %w", err)
        }</span>

        // If no results found, return the same cursor
        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                return results, exclusiveStartKey, nil
        }</span>

        // Check if we've reached the limit (more records might be available)
        <span class="cov0" title="0">if len(results) &lt; int(limit) </span><span class="cov0" title="0">{
                // No more records, return nil cursor to indicate end
                return results, nil, nil
        }</span>

        // Create next cursor
        <span class="cov0" title="0">var bk corev2.BlobKey
        copy(bk[:], lastBlobKey)
        nextCursor := &amp;StatusIndexCursor{
                BlobKey:   &amp;bk,
                UpdatedAt: lastUpdatedAt,
        }

        return results, nextCursor, nil</span>
}

// GetBlobMetadataCountByStatus counts the number of blobs with a given status
func (s *PostgresBlobMetadataStore) GetBlobMetadataCountByStatus(ctx context.Context, status v2.BlobStatus) (int32, error) <span class="cov0" title="0">{
        var count int32
        query := "SELECT COUNT(*) FROM blob_metadata WHERE blob_status = $1"
        err := s.db.GetContext(ctx, &amp;count, query, int(status))
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to count blob metadata by status: %w", err)
        }</span>
        <span class="cov0" title="0">return count, nil</span>
}

// queryBucketBlobMetadata retrieves blob metadata from a specific bucket
func (s *PostgresBlobMetadataStore) queryBucketBlobMetadata(
        ctx context.Context,
        bucket uint64,
        ascending bool,
        after BlobFeedCursor,
        before BlobFeedCursor,
        startKey string,
        endKey string,
        limit int,
        result []*v2.BlobMetadata,
        lastProcessedCursor **BlobFeedCursor,
) ([]*v2.BlobMetadata, error) <span class="cov0" title="0">{
        // Order by clause based on ascending flag
        orderBy := "ASC"
        if !ascending </span><span class="cov0" title="0">{
                orderBy = "DESC"
        }</span>

        // Limit clause
        <span class="cov0" title="0">limitClause := ""
        if limit &gt; 0 </span><span class="cov0" title="0">{
                remainingLimit := limit - len(result)
                if remainingLimit &lt;= 0 </span><span class="cov0" title="0">{
                        return result, nil
                }</span>
                <span class="cov0" title="0">limitClause = fmt.Sprintf("LIMIT %d", remainingLimit)</span>
        }

        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT blob_key, blob_header, requested_at, blob_status, updated_at
                FROM blob_metadata
                WHERE requested_at_bucket = $1 
                  AND requested_at_blob_key BETWEEN $2 AND $3
                ORDER BY requested_at_blob_key %s
                %s
        `, orderBy, limitClause)

        rows, err := s.db.QueryxContext(ctx, query, fmt.Sprintf("%d", bucket), startKey, endKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query blob metadata from bucket: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var rowData struct {
                        BlobKey     []byte `db:"blob_key"`
                        BlobHeader  []byte `db:"blob_header"`
                        RequestedAt uint64 `db:"requested_at"`
                        BlobStatus  int    `db:"blob_status"`
                        UpdatedAt   uint64 `db:"updated_at"`
                }

                if err := rows.StructScan(&amp;rowData); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan blob metadata: %w", err)
                }</span>

                <span class="cov0" title="0">metadata := &amp;v2.BlobMetadata{
                        RequestedAt: rowData.RequestedAt,
                        BlobStatus:  v2.BlobStatus(rowData.BlobStatus),
                        UpdatedAt:   rowData.UpdatedAt,
                }

                // Unmarshal BlobHeader
                err = json.Unmarshal(rowData.BlobHeader, &amp;metadata.BlobHeader)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal blob header: %w", err)
                }</span>

                // Get blob key for filtering
                <span class="cov0" title="0">blobKey, err := metadata.BlobHeader.BlobKey()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get blob key: %w", err)
                }</span>

                // Skip blobs at the endpoints (exclusive bounds)
                <span class="cov0" title="0">if after.Equal(metadata.RequestedAt, &amp;blobKey) || before.Equal(metadata.RequestedAt, &amp;blobKey) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Add to result
                <span class="cov0" title="0">result = append(result, metadata)

                // Update last processed cursor
                *lastProcessedCursor = &amp;BlobFeedCursor{
                        RequestedAt: metadata.RequestedAt,
                        BlobKey:     &amp;blobKey,
                }

                // Check limit
                if limit &gt; 0 &amp;&amp; len(result) &gt;= limit </span><span class="cov0" title="0">{
                        return result, nil
                }</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating through rows: %w", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// GetBlobMetadataByRequestedAtForward retrieves blob metadata ordered by requested time in ascending order
func (s *PostgresBlobMetadataStore) GetBlobMetadataByRequestedAtForward(
        ctx context.Context,
        after BlobFeedCursor,
        before BlobFeedCursor,
        limit int,
) ([]*v2.BlobMetadata, *BlobFeedCursor, error) <span class="cov0" title="0">{
        if !after.LessThan(&amp;before) </span><span class="cov0" title="0">{
                return nil, nil, errors.New("after cursor must be less than before cursor")
        }</span>

        <span class="cov0" title="0">startBucket, endBucket := GetRequestedAtBucketIDRange(after.RequestedAt, before.RequestedAt)
        startKey := after.ToCursorKey()
        endKey := before.ToCursorKey()
        result := make([]*v2.BlobMetadata, 0)
        var lastProcessedCursor *BlobFeedCursor

        for bucket := startBucket; bucket &lt;= endBucket; bucket++ </span><span class="cov0" title="0">{
                var err error
                result, err = s.queryBucketBlobMetadata(
                        ctx, bucket, true, after, before, startKey, endKey, limit, result, &amp;lastProcessedCursor,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>

                <span class="cov0" title="0">if limit &gt; 0 &amp;&amp; len(result) &gt;= limit </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return result, lastProcessedCursor, nil</span>
}

// GetBlobMetadataByRequestedAtBackward retrieves blob metadata ordered by requested time in descending order
func (s *PostgresBlobMetadataStore) GetBlobMetadataByRequestedAtBackward(
        ctx context.Context,
        before BlobFeedCursor,
        after BlobFeedCursor,
        limit int,
) ([]*v2.BlobMetadata, *BlobFeedCursor, error) <span class="cov0" title="0">{
        if !after.LessThan(&amp;before) </span><span class="cov0" title="0">{
                return nil, nil, errors.New("after cursor must be less than before cursor")
        }</span>

        <span class="cov0" title="0">startBucket, endBucket := GetRequestedAtBucketIDRange(after.RequestedAt, before.RequestedAt)
        startKey := after.ToCursorKey()
        endKey := before.ToCursorKey()
        result := make([]*v2.BlobMetadata, 0)
        var lastProcessedCursor *BlobFeedCursor

        // Traverse buckets in reverse order
        for bucket := endBucket; bucket &gt;= startBucket; bucket-- </span><span class="cov0" title="0">{
                var err error
                result, err = s.queryBucketBlobMetadata(
                        ctx, bucket, false, after, before, startKey, endKey, limit, result, &amp;lastProcessedCursor,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>

                <span class="cov0" title="0">if limit &gt; 0 &amp;&amp; len(result) &gt;= limit </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return result, lastProcessedCursor, nil</span>
}

// PutBlobCertificate stores a blob certificate
func (s *PostgresBlobMetadataStore) PutBlobCertificate(ctx context.Context, blobCert *corev2.BlobCertificate, fragmentInfo *encoding.FragmentInfo) error <span class="cov0" title="0">{
        // Marshal to JSON
        blobCertJSON, err := json.Marshal(blobCert)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal blob certificate: %w", err)
        }</span>

        <span class="cov0" title="0">fragmentInfoJSON, err := json.Marshal(fragmentInfo)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal fragment info: %w", err)
        }</span>

        // Get blob key
        <span class="cov0" title="0">blobKey, err := blobCert.BlobHeader.BlobKey()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get blob key: %w", err)
        }</span>

        // Insert into database
        <span class="cov0" title="0">query := `
                INSERT INTO blob_certificates (blob_key, blob_certificate, fragment_info)
                VALUES ($1, $2, $3)
                ON CONFLICT DO NOTHING
        `
        res, err := s.db.ExecContext(ctx, query, blobKey[:], blobCertJSON, fragmentInfoJSON)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert blob certificate: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return dispersercommon.ErrAlreadyExists
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteBlobCertificate deletes a blob certificate
func (s *PostgresBlobMetadataStore) DeleteBlobCertificate(ctx context.Context, blobKey corev2.BlobKey) error <span class="cov0" title="0">{
        query := "DELETE FROM blob_certificates WHERE blob_key = $1"
        _, err := s.db.ExecContext(ctx, query, blobKey[:])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete blob certificate: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetBlobCertificate retrieves a blob certificate
func (s *PostgresBlobMetadataStore) GetBlobCertificate(ctx context.Context, blobKey corev2.BlobKey) (*corev2.BlobCertificate, *encoding.FragmentInfo, error) <span class="cov0" title="0">{
        var result struct {
                BlobCertificate []byte `db:"blob_certificate"`
                FragmentInfo    []byte `db:"fragment_info"`
        }

        query := "SELECT blob_certificate, fragment_info FROM blob_certificates WHERE blob_key = $1"
        err := s.db.GetContext(ctx, &amp;result, query, blobKey[:])
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("%w: certificate not found for key %s", common.ErrMetadataNotFound, blobKey.Hex())
                }</span>
                <span class="cov0" title="0">return nil, nil, fmt.Errorf("failed to get blob certificate: %w", err)</span>
        }

        <span class="cov0" title="0">var cert corev2.BlobCertificate
        if err := json.Unmarshal(result.BlobCertificate, &amp;cert); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to unmarshal blob certificate: %w", err)
        }</span>

        <span class="cov0" title="0">var fragmentInfo encoding.FragmentInfo
        if err := json.Unmarshal(result.FragmentInfo, &amp;fragmentInfo); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to unmarshal fragment info: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;cert, &amp;fragmentInfo, nil</span>
}

// GetBlobCertificates retrieves multiple blob certificates
func (s *PostgresBlobMetadataStore) GetBlobCertificates(ctx context.Context, blobKeys []corev2.BlobKey) ([]*corev2.BlobCertificate, []*encoding.FragmentInfo, error) <span class="cov0" title="0">{
        if len(blobKeys) == 0 </span><span class="cov0" title="0">{
                return nil, nil, nil
        }</span>

        // Create placeholders for the IN clause
        <span class="cov0" title="0">placeholders := make([]string, len(blobKeys))
        args := make([]interface{}, len(blobKeys))
        for i, key := range blobKeys </span><span class="cov0" title="0">{
                placeholders[i] = fmt.Sprintf("$%d", i+1)
                args[i] = key[:]
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT blob_key, blob_certificate, fragment_info 
                FROM blob_certificates
                WHERE blob_key IN (%s)
        `, strings.Join(placeholders, ", "))

        rows, err := s.db.QueryxContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to query blob certificates: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        certs := make([]*corev2.BlobCertificate, 0, len(blobKeys))
        fragmentInfos := make([]*encoding.FragmentInfo, 0, len(blobKeys))

        for rows.Next() </span><span class="cov0" title="0">{
                var result struct {
                        BlobKey         []byte `db:"blob_key"`
                        BlobCertificate []byte `db:"blob_certificate"`
                        FragmentInfo    []byte `db:"fragment_info"`
                }

                if err := rows.StructScan(&amp;result); err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("failed to scan blob certificate: %w", err)
                }</span>

                <span class="cov0" title="0">var cert corev2.BlobCertificate
                if err := json.Unmarshal(result.BlobCertificate, &amp;cert); err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("failed to unmarshal blob certificate: %w", err)
                }</span>

                <span class="cov0" title="0">var fragmentInfo encoding.FragmentInfo
                if err := json.Unmarshal(result.FragmentInfo, &amp;fragmentInfo); err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("failed to unmarshal fragment info: %w", err)
                }</span>

                <span class="cov0" title="0">certs = append(certs, &amp;cert)
                fragmentInfos = append(fragmentInfos, &amp;fragmentInfo)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("error iterating through rows: %w", err)
        }</span>

        <span class="cov0" title="0">return certs, fragmentInfos, nil</span>
}

// PutBatch stores a batch
func (s *PostgresBlobMetadataStore) PutBatch(ctx context.Context, batch *corev2.Batch) error <span class="cov0" title="0">{
        // Marshal to JSON
        batchJSON, err := json.Marshal(batch)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal batch: %w", err)
        }</span>

        // Get batch header hash
        <span class="cov0" title="0">batchHeaderHash, err := batch.BatchHeader.Hash()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash batch header: %w", err)
        }</span>

        // Insert into database
        <span class="cov0" title="0">query := `
                INSERT INTO batches (batch_header_hash, batch_info)
                VALUES ($1, $2)
                ON CONFLICT DO NOTHING
        `
        res, err := s.db.ExecContext(ctx, query, batchHeaderHash[:], batchJSON)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert batch: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return dispersercommon.ErrAlreadyExists
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetBatch retrieves a batch by its header hash
func (s *PostgresBlobMetadataStore) GetBatch(ctx context.Context, batchHeaderHash [32]byte) (*corev2.Batch, error) <span class="cov0" title="0">{
        var batchJSON []byte

        query := "SELECT batch_info FROM batches WHERE batch_header_hash = $1"
        err := s.db.GetContext(ctx, &amp;batchJSON, query, batchHeaderHash[:])
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: batch info not found for hash %x", common.ErrMetadataNotFound, batchHeaderHash)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get batch: %w", err)</span>
        }

        <span class="cov0" title="0">var batch corev2.Batch
        if err := json.Unmarshal(batchJSON, &amp;batch); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal batch: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;batch, nil</span>
}

// PutBatchHeader stores a batch header
func (s *PostgresBlobMetadataStore) PutBatchHeader(ctx context.Context, batchHeader *corev2.BatchHeader) error <span class="cov0" title="0">{
        // Marshal to JSON
        batchHeaderJSON, err := json.Marshal(batchHeader)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal batch header: %w", err)
        }</span>

        // Get batch header hash
        <span class="cov0" title="0">batchHeaderHash, err := batchHeader.Hash()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash batch header: %w", err)
        }</span>

        // Insert into database
        <span class="cov0" title="0">query := `
                INSERT INTO batch_headers (batch_header_hash, batch_header)
                VALUES ($1, $2)
                ON CONFLICT DO NOTHING
        `
        res, err := s.db.ExecContext(ctx, query, batchHeaderHash[:], batchHeaderJSON)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert batch header: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return dispersercommon.ErrAlreadyExists
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteBatchHeader deletes a batch header
func (s *PostgresBlobMetadataStore) DeleteBatchHeader(ctx context.Context, batchHeaderHash [32]byte) error <span class="cov0" title="0">{
        query := "DELETE FROM batch_headers WHERE batch_header_hash = $1"
        _, err := s.db.ExecContext(ctx, query, batchHeaderHash[:])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete batch header: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetBatchHeader retrieves a batch header by its hash
func (s *PostgresBlobMetadataStore) GetBatchHeader(ctx context.Context, batchHeaderHash [32]byte) (*corev2.BatchHeader, error) <span class="cov0" title="0">{
        var batchHeaderJSON []byte

        query := "SELECT batch_header FROM batch_headers WHERE batch_header_hash = $1"
        err := s.db.GetContext(ctx, &amp;batchHeaderJSON, query, batchHeaderHash[:])
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: batch header not found for hash %x", common.ErrMetadataNotFound, batchHeaderHash)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get batch header: %w", err)</span>
        }

        <span class="cov0" title="0">var batchHeader corev2.BatchHeader
        if err := json.Unmarshal(batchHeaderJSON, &amp;batchHeader); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal batch header: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;batchHeader, nil</span>
}

// PutDispersalRequest stores a dispersal request
func (s *PostgresBlobMetadataStore) PutDispersalRequest(ctx context.Context, req *corev2.DispersalRequest) error <span class="cov0" title="0">{
        // Marshal to JSON
        reqJSON, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal dispersal request: %w", err)
        }</span>

        // Get batch header hash
        <span class="cov0" title="0">batchHeaderHash, err := req.BatchHeader.Hash()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash batch header: %w", err)
        }</span>

        // Insert into database
        <span class="cov0" title="0">query := `
                INSERT INTO dispersal_requests (batch_header_hash, operator_id, dispersal_request, dispersed_at)
                VALUES ($1, $2, $3, $4)
                ON CONFLICT DO NOTHING
        `
        res, err := s.db.ExecContext(ctx, query, batchHeaderHash[:], req.OperatorID[:], reqJSON, req.DispersedAt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert dispersal request: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return dispersercommon.ErrAlreadyExists
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDispersalRequest retrieves a dispersal request
func (s *PostgresBlobMetadataStore) GetDispersalRequest(ctx context.Context, batchHeaderHash [32]byte, operatorID core.OperatorID) (*corev2.DispersalRequest, error) <span class="cov0" title="0">{
        var reqJSON []byte

        query := "SELECT dispersal_request FROM dispersal_requests WHERE batch_header_hash = $1 AND operator_id = $2"
        err := s.db.GetContext(ctx, &amp;reqJSON, query, batchHeaderHash[:], operatorID[:])
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: dispersal request not found for batch header hash %x and operator %s", common.ErrMetadataNotFound, batchHeaderHash, operatorID.Hex())
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get dispersal request: %w", err)</span>
        }

        <span class="cov0" title="0">var req corev2.DispersalRequest
        if err := json.Unmarshal(reqJSON, &amp;req); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal dispersal request: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;req, nil</span>
}

// PutDispersalResponse stores a dispersal response
func (s *PostgresBlobMetadataStore) PutDispersalResponse(ctx context.Context, res *corev2.DispersalResponse) error <span class="cov0" title="0">{
        // Marshal to JSON
        resJSON, err := json.Marshal(res)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal dispersal response: %w", err)
        }</span>

        // Get batch header hash
        <span class="cov0" title="0">batchHeaderHash, err := res.BatchHeader.Hash()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash batch header: %w", err)
        }</span>

        // Insert into database
        <span class="cov0" title="0">query := `
                INSERT INTO dispersal_responses (batch_header_hash, operator_id, dispersal_response, responded_at)
                VALUES ($1, $2, $3, $4)
                ON CONFLICT DO NOTHING
        `
        result, err := s.db.ExecContext(ctx, query, batchHeaderHash[:], res.OperatorID[:], resJSON, res.RespondedAt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert dispersal response: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return dispersercommon.ErrAlreadyExists
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDispersalResponse retrieves a dispersal response
func (s *PostgresBlobMetadataStore) GetDispersalResponse(ctx context.Context, batchHeaderHash [32]byte, operatorID core.OperatorID) (*corev2.DispersalResponse, error) <span class="cov0" title="0">{
        var resJSON []byte

        query := "SELECT dispersal_response FROM dispersal_responses WHERE batch_header_hash = $1 AND operator_id = $2"
        err := s.db.GetContext(ctx, &amp;resJSON, query, batchHeaderHash[:], operatorID[:])
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: dispersal response not found for batch header hash %x and operator %s", common.ErrMetadataNotFound, batchHeaderHash, operatorID.Hex())
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get dispersal response: %w", err)</span>
        }

        <span class="cov0" title="0">var res corev2.DispersalResponse
        if err := json.Unmarshal(resJSON, &amp;res); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal dispersal response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;res, nil</span>
}

// GetDispersalResponses retrieves all dispersal responses for a batch
func (s *PostgresBlobMetadataStore) GetDispersalResponses(ctx context.Context, batchHeaderHash [32]byte) ([]*corev2.DispersalResponse, error) <span class="cov0" title="0">{
        query := "SELECT dispersal_response FROM dispersal_responses WHERE batch_header_hash = $1"
        rows, err := s.db.QueryContext(ctx, query, batchHeaderHash[:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query dispersal responses: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var responses []*corev2.DispersalResponse
        for rows.Next() </span><span class="cov0" title="0">{
                var resJSON []byte
                if err := rows.Scan(&amp;resJSON); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan dispersal response: %w", err)
                }</span>

                <span class="cov0" title="0">var res corev2.DispersalResponse
                if err := json.Unmarshal(resJSON, &amp;res); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal dispersal response: %w", err)
                }</span>

                <span class="cov0" title="0">responses = append(responses, &amp;res)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating through rows: %w", err)
        }</span>

        <span class="cov0" title="0">if len(responses) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: dispersal responses not found for batch header hash %x", common.ErrMetadataNotFound, batchHeaderHash)
        }</span>

        <span class="cov0" title="0">return responses, nil</span>
}

// GetDispersalsByRespondedAt retrieves dispersal responses within a time range
func (s *PostgresBlobMetadataStore) GetDispersalsByRespondedAt(
        ctx context.Context,
        operatorId core.OperatorID,
        start uint64,
        end uint64,
        limit int,
        ascending bool,
) ([]*corev2.DispersalResponse, error) <span class="cov0" title="0">{
        if start+1 &gt; end-1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no time point in exclusive time range (%d, %d)", start, end)
        }</span>

        // Adjust time range to be exclusive
        <span class="cov0" title="0">adjustedStart, adjustedEnd := start+1, end-1

        // Order by clause based on ascending flag
        orderBy := "ASC"
        if !ascending </span><span class="cov0" title="0">{
                orderBy = "DESC"
        }</span>

        // Limit clause
        <span class="cov0" title="0">limitClause := ""
        if limit &gt; 0 </span><span class="cov0" title="0">{
                limitClause = fmt.Sprintf("LIMIT %d", limit)
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT dispersal_response
                FROM dispersal_responses
                WHERE operator_id = $1 AND responded_at BETWEEN $2 AND $3
                ORDER BY responded_at %s
                %s
        `, orderBy, limitClause)

        rows, err := s.db.QueryContext(ctx, query, operatorId[:], adjustedStart, adjustedEnd)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query dispersal responses by responded at: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var responses []*corev2.DispersalResponse
        for rows.Next() </span><span class="cov0" title="0">{
                var resJSON []byte
                if err := rows.Scan(&amp;resJSON); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan dispersal response: %w", err)
                }</span>

                <span class="cov0" title="0">var res corev2.DispersalResponse
                if err := json.Unmarshal(resJSON, &amp;res); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal dispersal response: %w", err)
                }</span>

                <span class="cov0" title="0">responses = append(responses, &amp;res)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating through rows: %w", err)
        }</span>

        <span class="cov0" title="0">return responses, nil</span>
}

// PutAttestation stores an attestation
func (s *PostgresBlobMetadataStore) PutAttestation(ctx context.Context, attestation *corev2.Attestation) error <span class="cov0" title="0">{
        // Marshal to JSON
        attestationJSON, err := json.Marshal(attestation)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal attestation: %w", err)
        }</span>

        // Get batch header hash
        <span class="cov0" title="0">batchHeaderHash, err := attestation.BatchHeader.Hash()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash batch header: %w", err)
        }</span>

        // Insert into database - allow overwrite
        <span class="cov0" title="0">query := `
                INSERT INTO attestations (batch_header_hash, attestation, attested_at, attested_at_bucket)
                VALUES ($1, $2, $3, $4)
                ON CONFLICT (batch_header_hash) DO UPDATE
                SET attestation = $2, attested_at = $3, attested_at_bucket = $4
        `
        attestedAtBucket := computeAttestedAtBucket(attestation.AttestedAt)
        _, err = s.db.ExecContext(ctx, query, batchHeaderHash[:], attestationJSON, attestation.AttestedAt, attestedAtBucket)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert attestation: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetAttestation retrieves an attestation
func (s *PostgresBlobMetadataStore) GetAttestation(ctx context.Context, batchHeaderHash [32]byte) (*corev2.Attestation, error) <span class="cov0" title="0">{
        var attestationJSON []byte

        query := "SELECT attestation FROM attestations WHERE batch_header_hash = $1"
        err := s.db.GetContext(ctx, &amp;attestationJSON, query, batchHeaderHash[:])
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: attestation not found for hash %x", common.ErrMetadataNotFound, batchHeaderHash)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get attestation: %w", err)</span>
        }

        <span class="cov0" title="0">var attestation corev2.Attestation
        if err := json.Unmarshal(attestationJSON, &amp;attestation); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal attestation: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;attestation, nil</span>
}

// queryBucketAttestation retrieves attestations from a specific bucket
func (s *PostgresBlobMetadataStore) queryBucketAttestation(
        ctx context.Context,
        bucket, start, end uint64,
        numToReturn int,
        ascending bool,
) ([]*corev2.Attestation, error) <span class="cov0" title="0">{
        // Order by clause based on ascending flag
        orderBy := "ASC"
        if !ascending </span><span class="cov0" title="0">{
                orderBy = "DESC"
        }</span>

        // Limit clause
        <span class="cov0" title="0">limitClause := ""
        if numToReturn &gt; 0 </span><span class="cov0" title="0">{
                limitClause = fmt.Sprintf("LIMIT %d", numToReturn)
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT attestation
                FROM attestations
                WHERE attested_at_bucket = $1 AND attested_at BETWEEN $2 AND $3
                ORDER BY attested_at %s
                %s
        `, orderBy, limitClause)

        rows, err := s.db.QueryContext(ctx, query, fmt.Sprintf("%d", bucket), start, end)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query bucket attestations: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var attestations []*corev2.Attestation
        for rows.Next() </span><span class="cov0" title="0">{
                var attestationJSON []byte
                if err := rows.Scan(&amp;attestationJSON); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan attestation: %w", err)
                }</span>

                <span class="cov0" title="0">var attestation corev2.Attestation
                if err := json.Unmarshal(attestationJSON, &amp;attestation); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal attestation: %w", err)
                }</span>

                <span class="cov0" title="0">attestations = append(attestations, &amp;attestation)

                // Check limit
                if numToReturn &gt; 0 &amp;&amp; len(attestations) &gt;= numToReturn </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating through rows: %w", err)
        }</span>

        <span class="cov0" title="0">return attestations, nil</span>
}

// GetAttestationByAttestedAtForward retrieves attestations ordered by attested time in ascending order
func (s *PostgresBlobMetadataStore) GetAttestationByAttestedAtForward(
        ctx context.Context,
        after uint64,
        before uint64,
        limit int,
) ([]*corev2.Attestation, error) <span class="cov0" title="0">{
        if after+1 &gt; before-1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no time point in exclusive time range (%d, %d)", after, before)
        }</span>
        <span class="cov0" title="0">startBucket, endBucket := GetAttestedAtBucketIDRange(after, before)
        result := make([]*corev2.Attestation, 0)

        // Traverse buckets in forward order
        for bucket := startBucket; bucket &lt;= endBucket; bucket++ </span><span class="cov0" title="0">{
                if limit &gt; 0 &amp;&amp; len(result) &gt;= limit </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">remaining := math.MaxInt
                if limit &gt; 0 </span><span class="cov0" title="0">{
                        remaining = limit - len(result)
                }</span>
                // Query bucket in ascending order
                <span class="cov0" title="0">bucketAttestation, err := s.queryBucketAttestation(ctx, bucket, after+1, before-1, remaining, true)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">for _, ba := range bucketAttestation </span><span class="cov0" title="0">{
                        result = append(result, ba)
                        if limit &gt; 0 &amp;&amp; len(result) &gt;= limit </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">return result, nil</span>
}

// GetAttestationByAttestedAtBackward retrieves attestations ordered by attested time in descending order
func (s *PostgresBlobMetadataStore) GetAttestationByAttestedAtBackward(
        ctx context.Context,
        before uint64,
        after uint64,
        limit int,
) ([]*corev2.Attestation, error) <span class="cov0" title="0">{
        if after+1 &gt; before-1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no time point in exclusive time range (%d, %d)", after, before)
        }</span>
        // Note: we traverse buckets in reverse order for backward query
        <span class="cov0" title="0">startBucket, endBucket := GetAttestedAtBucketIDRange(after, before)
        result := make([]*corev2.Attestation, 0)

        // Traverse buckets in reverse order
        for bucket := endBucket; bucket &gt;= startBucket; bucket-- </span><span class="cov0" title="0">{
                if limit &gt; 0 &amp;&amp; len(result) &gt;= limit </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">remaining := math.MaxInt
                if limit &gt; 0 </span><span class="cov0" title="0">{
                        remaining = limit - len(result)
                }</span>
                // Query bucket in descending order
                <span class="cov0" title="0">bucketAttestation, err := s.queryBucketAttestation(ctx, bucket, after+1, before-1, remaining, false)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">for _, ba := range bucketAttestation </span><span class="cov0" title="0">{
                        result = append(result, ba)
                        if limit &gt; 0 &amp;&amp; len(result) &gt;= limit </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

// PutBlobInclusionInfo stores blob inclusion information
func (s *PostgresBlobMetadataStore) PutBlobInclusionInfo(ctx context.Context, inclusionInfo *corev2.BlobInclusionInfo) error <span class="cov0" title="0">{
        // Marshal to JSON
        inclusionInfoJSON, err := json.Marshal(inclusionInfo)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal blob inclusion info: %w", err)
        }</span>

        // Get batch header hash
        <span class="cov0" title="0">batchHeaderHash, err := inclusionInfo.BatchHeader.Hash()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash batch header: %w", err)
        }</span>

        // Insert into database
        <span class="cov0" title="0">query := `
                INSERT INTO blob_inclusion_info (blob_key, batch_header_hash, inclusion_info)
                VALUES ($1, $2, $3)
                ON CONFLICT DO NOTHING
        `
        res, err := s.db.ExecContext(ctx, query, inclusionInfo.BlobKey[:], batchHeaderHash[:], inclusionInfoJSON)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert blob inclusion info: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return dispersercommon.ErrAlreadyExists
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// PutBlobInclusionInfos stores multiple blob inclusion information entries
func (s *PostgresBlobMetadataStore) PutBlobInclusionInfos(ctx context.Context, inclusionInfos []*corev2.BlobInclusionInfo) error <span class="cov0" title="0">{
        if len(inclusionInfos) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Start a transaction
        <span class="cov0" title="0">tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Prepare statement
        stmt, err := tx.Prepare(`
                INSERT INTO blob_inclusion_info (blob_key, batch_header_hash, inclusion_info)
                VALUES ($1, $2, $3)
                ON CONFLICT DO NOTHING
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to prepare statement: %w", err)
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        // Insert each inclusion info
        for _, info := range inclusionInfos </span><span class="cov0" title="0">{
                // Marshal to JSON
                inclusionInfoJSON, err := json.Marshal(info)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal blob inclusion info: %w", err)
                }</span>

                // Get batch header hash
                <span class="cov0" title="0">batchHeaderHash, err := info.BatchHeader.Hash()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to hash batch header: %w", err)
                }</span>

                <span class="cov0" title="0">_, err = stmt.Exec(info.BlobKey[:], batchHeaderHash[:], inclusionInfoJSON)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to insert blob inclusion info: %w", err)
                }</span>
        }

        // Commit transaction
        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetBlobInclusionInfo retrieves blob inclusion information
func (s *PostgresBlobMetadataStore) GetBlobInclusionInfo(ctx context.Context, blobKey corev2.BlobKey, batchHeaderHash [32]byte) (*corev2.BlobInclusionInfo, error) <span class="cov0" title="0">{
        var inclusionInfoJSON []byte

        query := "SELECT inclusion_info FROM blob_inclusion_info WHERE blob_key = $1 AND batch_header_hash = $2"
        err := s.db.GetContext(ctx, &amp;inclusionInfoJSON, query, blobKey[:], batchHeaderHash[:])
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: inclusion info not found for key %s", common.ErrMetadataNotFound, blobKey.Hex())
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get blob inclusion info: %w", err)</span>
        }

        <span class="cov0" title="0">var inclusionInfo corev2.BlobInclusionInfo
        if err := json.Unmarshal(inclusionInfoJSON, &amp;inclusionInfo); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal blob inclusion info: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;inclusionInfo, nil</span>
}

// GetBlobInclusionInfos retrieves all inclusion information for a blob
func (s *PostgresBlobMetadataStore) GetBlobInclusionInfos(ctx context.Context, blobKey corev2.BlobKey) ([]*corev2.BlobInclusionInfo, error) <span class="cov0" title="0">{
        query := "SELECT inclusion_info FROM blob_inclusion_info WHERE blob_key = $1"
        rows, err := s.db.QueryContext(ctx, query, blobKey[:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query blob inclusion infos: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var inclusionInfos []*corev2.BlobInclusionInfo
        for rows.Next() </span><span class="cov0" title="0">{
                var inclusionInfoJSON []byte
                if err := rows.Scan(&amp;inclusionInfoJSON); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan blob inclusion info: %w", err)
                }</span>

                <span class="cov0" title="0">var inclusionInfo corev2.BlobInclusionInfo
                if err := json.Unmarshal(inclusionInfoJSON, &amp;inclusionInfo); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal blob inclusion info: %w", err)
                }</span>

                <span class="cov0" title="0">inclusionInfos = append(inclusionInfos, &amp;inclusionInfo)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating through rows: %w", err)
        }</span>

        <span class="cov0" title="0">if len(inclusionInfos) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: inclusion info not found for key %s", common.ErrMetadataNotFound, blobKey.Hex())
        }</span>

        <span class="cov0" title="0">return inclusionInfos, nil</span>
}

// GetBlobAttestationInfo retrieves blob attestation information
func (s *PostgresBlobMetadataStore) GetBlobAttestationInfo(ctx context.Context, blobKey corev2.BlobKey) (*v2.BlobAttestationInfo, error) <span class="cov0" title="0">{
        blobInclusionInfos, err := s.GetBlobInclusionInfos(ctx, blobKey)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to get blob inclusion info for blob", "err", err, "blobKey", blobKey.Hex())
                return nil, api.NewErrorInternal(fmt.Sprintf("failed to get blob inclusion info: %s", err.Error()))
        }</span>

        <span class="cov0" title="0">if len(blobInclusionInfos) == 0 </span><span class="cov0" title="0">{
                s.logger.Error("no blob inclusion info found for blob", "blobKey", blobKey.Hex())
                return nil, api.NewErrorInternal("no blob inclusion info found")
        }</span>

        <span class="cov0" title="0">if len(blobInclusionInfos) &gt; 1 </span><span class="cov0" title="0">{
                s.logger.Warn("multiple inclusion info found for blob", "blobKey", blobKey.Hex())
        }</span>

        // Keep track of the non-transient error to return at the end if no attestation is found
        <span class="cov0" title="0">var nonTransientErr error
        
        for _, inclusionInfo := range blobInclusionInfos </span><span class="cov0" title="0">{
                // get the signed batch from this inclusion info
                batchHeaderHash, err := inclusionInfo.BatchHeader.Hash()
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("failed to get batch header hash from blob inclusion info", "err", err, "blobKey", blobKey.Hex())
                        nonTransientErr = err
                        continue</span>
                }
                <span class="cov0" title="0">_, attestation, err := s.GetSignedBatch(ctx, batchHeaderHash)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("failed to get signed batch", "err", err, "blobKey", blobKey.Hex())
                        nonTransientErr = err
                        continue</span>
                }

                <span class="cov0" title="0">return &amp;v2.BlobAttestationInfo{
                        InclusionInfo: inclusionInfo,
                        Attestation:   attestation,
                }, nil</span>
        }

        <span class="cov0" title="0">if nonTransientErr != nil </span><span class="cov0" title="0">{
                return nil, nonTransientErr
        }</span>
        
        <span class="cov0" title="0">return nil, fmt.Errorf("no attestation info found for blobkey: %s", blobKey.Hex())</span>
}

// GetSignedBatch retrieves a batch header and its attestation
func (s *PostgresBlobMetadataStore) GetSignedBatch(ctx context.Context, batchHeaderHash [32]byte) (*corev2.BatchHeader, *corev2.Attestation, error) <span class="cov0" title="0">{
        // Get batch header
        batchHeader, err := s.GetBatchHeader(ctx, batchHeaderHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get batch header: %w", err)
        }</span>

        // Get attestation
        <span class="cov0" title="0">attestation, err := s.GetAttestation(ctx, batchHeaderHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get attestation: %w", err)
        }</span>

        <span class="cov0" title="0">return batchHeader, attestation, nil</span>
}

// Close closes the database connection
func (s *PostgresBlobMetadataStore) Close() error <span class="cov0" title="0">{
        return s.db.Close()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package blobstore

import (
        "context"

        "github.com/Layr-Labs/eigenda/common/aws/s3"
        corev2 "github.com/Layr-Labs/eigenda/core/v2"
        "github.com/Layr-Labs/eigenda/disperser/common"
        "github.com/Layr-Labs/eigensdk-go/logging"
        "github.com/pkg/errors"
)

type BlobStore struct {
        bucketName string
        s3Client   s3.Client
        logger     logging.Logger
}

func NewBlobStore(s3BucketName string, s3Client s3.Client, logger logging.Logger) *BlobStore <span class="cov8" title="1">{
        return &amp;BlobStore{
                bucketName: s3BucketName,
                s3Client:   s3Client,
                logger:     logger,
        }
}</span>

// StoreBlob adds a blob to the blob store
func (b *BlobStore) StoreBlob(ctx context.Context, key corev2.BlobKey, data []byte) error <span class="cov8" title="1">{
        _, err := b.s3Client.HeadObject(ctx, b.bucketName, s3.ScopedBlobKey(key))
        if err == nil </span><span class="cov0" title="0">{
                b.logger.Warnf("blob already exists in bucket %s: %s", b.bucketName, key)
                return common.ErrAlreadyExists
        }</span>

        <span class="cov8" title="1">err = b.s3Client.UploadObject(ctx, b.bucketName, s3.ScopedBlobKey(key), data)
        if err != nil </span><span class="cov0" title="0">{
                b.logger.Errorf("failed to upload blob in bucket %s: %v", b.bucketName, err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetBlob retrieves a blob from the blob store
func (b *BlobStore) GetBlob(ctx context.Context, key corev2.BlobKey) ([]byte, error) <span class="cov8" title="1">{
        data, err := b.s3Client.DownloadObject(ctx, b.bucketName, s3.ScopedBlobKey(key))
        if errors.Is(err, s3.ErrObjectNotFound) </span><span class="cov0" title="0">{
                b.logger.Warnf("blob not found in bucket %s: %s", b.bucketName, key)
                return nil, common.ErrBlobNotFound
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                b.logger.Errorf("failed to download blob from bucket %s: %v", b.bucketName, err)
                return nil, err
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
