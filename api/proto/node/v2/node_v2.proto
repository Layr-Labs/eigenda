syntax = "proto3";
package node.v2;
import "common/v2/common.proto";
option go_package = "github.com/Layr-Labs/eigenda/api/grpc/node/v2";

// The EigenDA Node implements two services, Dispersal and Retrieval, as defined below,
// for better security and separation of concerns.

// Dispersal is utilized to disperse chunk data. The disperser calls these RPCs to store chunks on individual DA nodes.
service Dispersal {
  // StoreChunks stores a batch of chunks on the Node.
  rpc StoreChunks(StoreChunksRequest) returns (StoreChunksReply) {}
  // NodeInfo fetches metadata about the node.
  rpc NodeInfo(NodeInfoRequest) returns (NodeInfoReply) {}
}

// Retrieval is utilized to retrieve chunk data. This chunk data can be used to reconstruct the original blob.
service Retrieval {
  // GetChunks retrieves the chunks for a blob custodied at the Node. Note that where possible, it is generally
  // faster to retrieve chunks from the relay service if that service is available.
  rpc GetChunks(GetChunksRequest) returns (GetChunksReply) {}
  // Retrieve node info metadata
  rpc NodeInfo(NodeInfoRequest) returns (NodeInfoReply) {}
}

// Requests and replies

// Request that the Node store a batch of chunks.
message StoreChunksRequest {
  // batch of blobs to store
  common.v2.Batch batch = 1;

  // ID of the disperser that is requesting the storage of the batch.
  uint32 disperserID = 2;

  // Signature using the disperser's ECDSA key over keccak hash of the batch. The purpose of this signature
  // is to prevent hooligans from tricking DA nodes into storing data that they shouldn't be storing.
  //
  // Algorithm for computing the hash is as follows. All integer values are serialized in big-endian order (unsigned).
  // A reference implementation (golang) can be found at
  // https://github.com/Layr-Labs/eigenda/blob/master/disperser/auth/request_signing.go
  //
  // 1. digest batch.BatchHeader.BatchRoot
  // 2. digest batch.BatchHeader.ReferenceBlockNumber (8 bytes, unsigned big endian)
  // 3. for each certificate in batch.BlobCertificates:
  //   a. digest certificate.BlobHeader.Version (4 bytes, unsigned big endian)
  //   b. for each quorum_number in certificate.BlobHeader.QuorumNumbers:
  //     i. digest quorum_number (4 bytes, unsigned big endian)
  //   c. digest certificate.BlobHeader.Commitment.Commitment
  //   d. digest certificate.BlobHeader.Commitment.LengthCommitment
  //   e. digest certificate.BlobHeader.Commitment.LengthProof
  //   f. digest certificate.BlobHeader.Commitment.Length (4 bytes, unsigned big endian)
  //   g. digest certificate.BlobHeader.PaymentHeader.AccountId
  //   h. digest certificate.BlobHeader.PaymentHeader.ReservationPeriod (4 bytes, unsigned big endian)
  //   i. digest certificate.BlobHeader.PaymentHeader.CumulativePayment
  //   j. digest certificate.BlobHeader.PaymentHeader.Salt (4 bytes, unsigned big endian)
  //   k. digest certificate.BlobHeader.Signature
  //   l. for each relay in certificate.Relays:
  //     i. digest relay (4 bytes, unsigned big endian)
  // 4. digest disperserID (4 bytes, unsigned big endian)
  //
  // Note that this signature is not included in the hash for obvious reasons.
  bytes signature = 3;
}

// StoreChunksReply is the message type used to respond to a StoreChunks() RPC.
message StoreChunksReply {
  // a custody signature of the received batch
  bytes signature = 1;
}

// The parameter for the GetChunks() RPC.
message GetChunksRequest {
  // The unique identifier for the blob the chunks are being requested for.
  bytes blob_key = 1;
  // Which quorum of the blob to retrieve for (note: a blob can have multiple
  // quorums and the chunks for different quorums at a Node can be different).
  // The ID must be in range [0, 254].
  uint32 quorum_id = 2;
}

// The response to the GetChunks() RPC.
message GetChunksReply {
  // All chunks the Node is storing for the requested blob per RetrieveChunksRequest.
  repeated bytes chunks = 1;
}

// The parameter for the NodeInfo() RPC.
message NodeInfoRequest {
}

// Node info reply
message NodeInfoReply {
  // The version of the node.
  string semver = 1;
  // The architecture of the node.
  string arch = 2;
  // The operating system of the node.
  string os = 3;
  // The number of CPUs on the node.
  uint32 num_cpu = 4;
  // The amount of memory on the node in bytes.
  uint64 mem_bytes = 5;
}
