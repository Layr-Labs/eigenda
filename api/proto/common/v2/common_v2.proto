syntax = "proto3";
package common.v2;
import "common/common.proto";
option go_package = "github.com/Layr-Labs/eigenda/api/grpc/common/v2";

// BlobHeader contains the information describing a blob and the way it is to be dispersed.
message BlobHeader {
  // The blob version. Blob versions are pushed onchain by EigenDA governance in an append only fashion and store the
  // maximum number of operators, number of chunks, and coding rate for a blob. On blob verification, these values
  // are checked against supplied or default security thresholds to validate the security assumptions of the
  // blob's availability.
  uint32 version = 1;
  // quorum_numbers is the list of quorum numbers that the blob is part of.
  // All quorums must be specified (including required quorums).
  //
  // The following quorums are currently required:
  // - 0: ETH
  // - 1: EIGEN
  repeated uint32 quorum_numbers = 2;
  // commitment is the KZG commitment to the blob
  common.BlobCommitment commitment = 3;
  // payment_header contains payment information for the blob
  common.PaymentHeader payment_header = 4;
  // signature over keccak hash of the blob_header that can be verified by blob_header.account_id
  bytes signature = 5;
}

// BlobCertificate contains a full description of a blob and how it is dispersed. Part of the certificate
// is provided by the blob submitter (i.e. the blob header), and part is provided by the disperser (i.e. the relays).
// Validator nodes eventually sign the blob certificate once they are in custody of the required chunks
// (note that the signature is indirect; validators sign the hash of a Batch, which contains the blob certificate).
message BlobCertificate {
  // blob_header contains data about the blob.
  BlobHeader blob_header = 1;
  // relays is the list of relays that are in custody of the blob.
  // The relays custodying the data are chosen by the Disperser to which the DisperseBlob request was submitted.
  // It needs to contain at least 1 relay number.
  // To retrieve a blob from the relay, one can find that relay's URL in the EigenDARelayRegistry contract:
  // https://github.com/Layr-Labs/eigenda/blob/master/contracts/src/core/EigenDARelayRegistry.sol
  repeated uint32 relays = 2;
}

// BatchHeader is the header of a batch of blobs
message BatchHeader {
  // batch_root is the root of the merkle tree of the hashes of blob certificates in the batch
  bytes batch_root = 1;
  // reference_block_number is the block number that the state of the batch is based on for attestation
  uint64 reference_block_number = 2;
}

// Batch is a batch of blob certificates
message Batch {
  // header contains metadata about the batch
  BatchHeader header = 1;
  // blob_certificates is the list of blob certificates in the batch
  repeated BlobCertificate blob_certificates = 2;
}
