syntax = "proto3";
package common;
option go_package = "github.com/Layr-Labs/eigenda/api/grpc/common";

// G1Commitment represents the serialized coordinates of a G1 KZG commitment.
// We use gnark-crypto so adopt its serialization, which is big-endian. See:
// https://github.com/Consensys/gnark-crypto/blob/779e884dabb38b92e677f4891286637a3d2e5734/ecc/bn254/fp/element.go#L862
message G1Commitment {
  // The X coordinate of the KZG commitment. This is the raw byte representation of the field element.
  bytes x = 1;
  // The Y coordinate of the KZG commitment. This is the raw byte representation of the field element.
  bytes y = 2;
}

// BlobCommitment represents commitment of a specific blob, containing its
// KZG commitment, degree proof, the actual degree, and data length in number of symbols (field elements).
// It deserializes into https://github.com/Layr-Labs/eigenda/blob/ce89dab18d2f8f55004002e17dd3a18529277845/encoding/data.go#L27
//
// See https://github.com/Layr-Labs/eigenda/blob/master/docs/spec/attestation/encoding.md#validation-via-kzg
// to understand how this commitment is used to validate the blob.
message BlobCommitment {
  // Concatenation of the x and y coordinates of `common.G1Commitment`.
  bytes commitment = 1;
  // Serialization of the G2Commitment to the blob length.
  bytes length_commitment = 2;
  // Serialization of the G2Affine element representing the proof of the blob length.
  bytes length_proof = 3;
  // The length of the blob in symbols (field elements).
  // TODO: is this length always a power of 2? Are there any other characteristics that we should list? etc.
  uint32 length = 4;
}

message PaymentHeader {
  // The account ID of the disperser client. This should be a hex-encoded string of the ECSDA public key
  // corresponding to the key used by the client to sign the BlobHeader.
  string account_id = 1;
  // The reservation period of the dispersal request.
  uint32 reservation_period = 2;
  // The cumulative payment of the dispersal request. 
  bytes cumulative_payment = 3;
  // The salt of the disperser request. This is used to ensure that the payment header is intentionally unique.
  uint32 salt = 4;
}
