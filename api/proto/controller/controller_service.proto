syntax = "proto3";
package controller;

import "common/v2/common_v2.proto";
import "validator/signing_rate.proto";

option go_package = "github.com/Layr-Labs/eigenda/api/grpc/controller";

// ControllerService defines the APIs for the controller.
//
// Currently, this API is only intended for *internal* consumption: this is a way for different parts of the disperser
// to communicate with each other
service ControllerService {
  // AuthorizePayment handles payment authorization for blob dispersal
  //
  // This is intended to be called by API server instances that are handling dispersal requests. The controller
  // is responsible for accounting and metering for the dispersal.
  //
  // While this endpoint *does* verify the client signature for each dispersal, it *does not* have any type of auth
  // implemented between the API Server and Controller:
  // - This is an internal API protected by firewall rules, so it is unlikely that an unauthorized party would be able
  // to gain access to it.
  // - In the event that an unauthorized party were to gain access to this endpoint, the attack surface area is still
  // minimal: client signatures are being checked, and we protect against replay. Therefore, the attacker wouldn't be
  // able to waste user funds. They would only be able to attack the liveness of the Controller through high submission
  // volume, which would be a vulnerability regardless of whether we had auth between the API server and the Controller.
  rpc AuthorizePayment(AuthorizePaymentRequest) returns (AuthorizePaymentResponse) {}

  // GetValidatorSigningRate returns the signing rate of a validator during a time range.
  rpc GetValidatorSigningRate(GetValidatorSigningRateRequest) returns (GetValidatorSigningRateReply) {}

  // Request a dump of signing rate data for all validators after a specified start time.
  rpc GetValidatorSigningRateDump(GetValidatorSigningRateDumpRequest) returns (GetValidatorSigningRateDumpReply) {}
}

// Contains all information necessary for the controller to evaluate the validity of a dispersal payment
message AuthorizePaymentRequest {
  // The blob header is used for the following purposes:
  // 1. Contains the PaymentHeader, which describes the payment being offered
  // 2. Contains the quorums being dispersed to
  common.v2.BlobHeader blob_header = 1;

  // Client's ECDSA signature over the blob header's blobKey (keccak hash of the blob header).
  // This signature can be verified against the account ID in the payment header.
  bytes client_signature = 2;
}

// AuthorizePaymentResponse is returned after the controller does accounting and metering.
// - *Accounting* involves checking that there are enough funds/reservation bandwidth available to pay for a dispersal
// - *Metering* involves checking that EigenDA throughput limits are respected, irrespective of client payment validity
//
// A GRPC error indicates that there was a problem with either accounting or metering.
// No error means everything succeeded.
//
// Possible error cases (not an exhaustive list):
// - Unauthenticated: Invalid client signature
// - PermissionDenied: Client signature is valid, but payment is insufficient or account has exceeded reservation limits
// - ResourceExhausted: Metering check failed - total network on-demand throughput is exhausted
message AuthorizePaymentResponse {}

// A request to get the signing rate of a validator during a time range. The time range of the returned data may not
// exactly match the requested time range, as the data is aggregated into fixed size buckets.
message GetValidatorSigningRateRequest {
  // The unique identifier of the validator (i.e. the operator ID).
  bytes validator_id = 1;
  // The start of the time range to query the signing rate for, in seconds since Unix epoch. If there is a bucket that
  // starts before but ends after this timestamp, that bucket will be included in the response, even though
  // some of its data is before the requested start time.
  uint64 start_timestamp = 2;
  // The end time of the range, in seconds since Unix epoch (exclusive). If a bucket's start time is greater than
  // or equal to this timestamp, it will not be included in the response. If a bucket's start time is before this 
  // timestamp and its end time is after or equal to this timestamp, it will be included in the response, even though
  // some of its data is after the requested end time.
  uint64 end_timestamp = 3;
}

// A reply containing the signing rate of a validator during a time range.
message GetValidatorSigningRateReply {
  // The start time of the range, in seconds since Unix epoch, inclusive. May be different from the requested start time
  // (in order to align with bucket boundaries).
  uint64 start_timestamp = 1;
  // The end time of the range, in seconds since Unix epoch, exclusive. May be different from the requested end time
  // (in order to align with bucket boundaries).
  uint64 end_timestamp = 2;
  // The signing rate of the validator during the time range.
  validator.ValidatorSigningRate validator_signing_rate = 3;
}

// A request to get a dump of signing rate data for all validators after a specified start time.
message GetValidatorSigningRateDumpRequest {
  // Request all signing rate data starting from this time, in seconds since Unix epoch.
  uint64 start_timestamp = 1;
}

// A reply containing the signing rate data for all validators after a specified start time.
message GetValidatorSigningRateDumpReply {
  // The signing rate data for all validators after the specified start time. If too much data is requested
  // in a single request, the server may only send a partial dump. To get a full dump, call this RPC
  // multiple times, using the end_timestamp of the last bucket received as the start_timestamp of the next request.
  repeated validator.SigningRateBucket signing_rate_buckets = 1;
}
