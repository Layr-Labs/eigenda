<!DOCTYPE html>

<html>
  <head>
    <title>Protocol Documentation</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>
    <style>
      body {
        width: 60em;
        margin: 1em auto;
        color: #222;
        font-family: "Ubuntu", sans-serif;
        padding-bottom: 4em;
      }

      h1 {
        font-weight: normal;
        border-bottom: 1px solid #aaa;
        padding-bottom: 0.5ex;
      }

      h2 {
        border-bottom: 1px solid #aaa;
        padding-bottom: 0.5ex;
        margin: 1.5em 0;
      }

      h3 {
        font-weight: normal;
        border-bottom: 1px solid #aaa;
        padding-bottom: 0.5ex;
      }

      a {
        text-decoration: none;
        color: #567e25;
      }

      table {
        width: 100%;
        font-size: 80%;
        border-collapse: collapse;
      }

      thead {
        font-weight: 700;
        background-color: #dcdcdc;
      }

      tbody tr:nth-child(even) {
        background-color: #fbfbfb;
      }

      td {
        border: 1px solid #ccc;
        padding: 0.5ex 2ex;
      }

      td p {
        text-indent: 1em;
        margin: 0;
      }

      td p:nth-child(1) {
        text-indent: 0;  
      }

       
      .field-table td:nth-child(1) {  
        width: 10em;
      }
      .field-table td:nth-child(2) {  
        width: 10em;
      }
      .field-table td:nth-child(3) {  
        width: 6em;
      }
      .field-table td:nth-child(4) {  
        width: auto;
      }

       
      .extension-table td:nth-child(1) {  
        width: 10em;
      }
      .extension-table td:nth-child(2) {  
        width: 10em;
      }
      .extension-table td:nth-child(3) {  
        width: 10em;
      }
      .extension-table td:nth-child(4) {  
        width: 5em;
      }
      .extension-table td:nth-child(5) {  
        width: auto;
      }

       
      .enum-table td:nth-child(1) {  
        width: 10em;
      }
      .enum-table td:nth-child(2) {  
        width: 10em;
      }
      .enum-table td:nth-child(3) {  
        width: auto;
      }

       
      .scalar-value-types-table tr {
        height: 3em;
      }

       
      #toc-container ul {
        list-style-type: none;
        padding-left: 1em;
        line-height: 180%;
        margin: 0;
      }
      #toc > li > a {
        font-weight: bold;
      }

       
      .file-heading {
        width: 100%;
        display: table;
        border-bottom: 1px solid #aaa;
        margin: 4em 0 1.5em 0;
      }
      .file-heading h2 {
        border: none;
        display: table-cell;
      }
      .file-heading a {
        text-align: right;
        display: table-cell;
      }

       
      .badge {
        width: 1.6em;
        height: 1.6em;
        display: inline-block;

        line-height: 1.6em;
        text-align: center;
        font-weight: bold;
        font-size: 60%;

        color: #89ba48;
        background-color: #dff0c8;

        margin: 0.5ex 1em 0.5ex -1em;
        border: 1px solid #fbfbfb;
        border-radius: 1ex;
      }
    </style>

    
    <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
  </head>

  <body>

    <h1 id="title">Protocol Documentation</h1>

    <h2>Table of Contents</h2>

    <div id="toc-container">
      <ul id="toc">
        
          
          <li>
            <a href="#disperser%2fv2%2fdisperser_v2.proto">disperser/v2/disperser_v2.proto</a>
            <ul>
              
                <li>
                  <a href="#disperser.v2.Attestation"><span class="badge">M</span>Attestation</a>
                </li>
              
                <li>
                  <a href="#disperser.v2.BlobCommitmentReply"><span class="badge">M</span>BlobCommitmentReply</a>
                </li>
              
                <li>
                  <a href="#disperser.v2.BlobCommitmentRequest"><span class="badge">M</span>BlobCommitmentRequest</a>
                </li>
              
                <li>
                  <a href="#disperser.v2.BlobInclusionInfo"><span class="badge">M</span>BlobInclusionInfo</a>
                </li>
              
                <li>
                  <a href="#disperser.v2.BlobStatusReply"><span class="badge">M</span>BlobStatusReply</a>
                </li>
              
                <li>
                  <a href="#disperser.v2.BlobStatusRequest"><span class="badge">M</span>BlobStatusRequest</a>
                </li>
              
                <li>
                  <a href="#disperser.v2.DisperseBlobReply"><span class="badge">M</span>DisperseBlobReply</a>
                </li>
              
                <li>
                  <a href="#disperser.v2.DisperseBlobRequest"><span class="badge">M</span>DisperseBlobRequest</a>
                </li>
              
                <li>
                  <a href="#disperser.v2.GetPaymentStateReply"><span class="badge">M</span>GetPaymentStateReply</a>
                </li>
              
                <li>
                  <a href="#disperser.v2.GetPaymentStateRequest"><span class="badge">M</span>GetPaymentStateRequest</a>
                </li>
              
                <li>
                  <a href="#disperser.v2.PaymentGlobalParams"><span class="badge">M</span>PaymentGlobalParams</a>
                </li>
              
                <li>
                  <a href="#disperser.v2.PeriodRecord"><span class="badge">M</span>PeriodRecord</a>
                </li>
              
                <li>
                  <a href="#disperser.v2.Reservation"><span class="badge">M</span>Reservation</a>
                </li>
              
                <li>
                  <a href="#disperser.v2.SignedBatch"><span class="badge">M</span>SignedBatch</a>
                </li>
              
              
                <li>
                  <a href="#disperser.v2.BlobStatus"><span class="badge">E</span>BlobStatus</a>
                </li>
              
              
              
                <li>
                  <a href="#disperser.v2.Disperser"><span class="badge">S</span>Disperser</a>
                </li>
              
            </ul>
          </li>
        
        <li><a href="#scalar-value-types">Scalar Value Types</a></li>
      </ul>
    </div>

    
      
      <div class="file-heading">
        <h2 id="disperser/v2/disperser_v2.proto">disperser/v2/disperser_v2.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="disperser.v2.Attestation">Attestation</h3>
        <p></p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>non_signer_pubkeys</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td>repeated</td>
                  <td><p>Serialized bytes of non signer public keys (G1 points) </p></td>
                </tr>
              
                <tr>
                  <td>apk_g2</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>Serialized bytes of G2 point that represents aggregate public key of all signers </p></td>
                </tr>
              
                <tr>
                  <td>quorum_apks</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td>repeated</td>
                  <td><p>Serialized bytes of aggregate public keys (G1 points) from all nodes for each quorum
The order of the quorum_apks should match the order of the quorum_numbers </p></td>
                </tr>
              
                <tr>
                  <td>sigma</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>Serialized bytes of aggregate signature </p></td>
                </tr>
              
                <tr>
                  <td>quorum_numbers</td>
                  <td><a href="#uint32">uint32</a></td>
                  <td>repeated</td>
                  <td><p>Relevant quorum numbers for the attestation </p></td>
                </tr>
              
                <tr>
                  <td>quorum_signed_percentages</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The attestation rate for each quorum. Each quorum&#39;s signing percentage is represented by
an 8 bit unsigned integer. The integer is the fraction of the quorum that has signed, with
100 representing 100% of the quorum signing, and 0 representing 0% of the quorum signing. The first
byte in the byte array corresponds to the first quorum in the quorum_numbers array, the second byte
corresponds to the second quorum, and so on. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="disperser.v2.BlobCommitmentReply">BlobCommitmentReply</h3>
        <p>The result of a BlobCommitmentRequest().</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>blob_commitment</td>
                  <td><a href="#common.BlobCommitment">common.BlobCommitment</a></td>
                  <td></td>
                  <td><p>The commitment of the blob. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="disperser.v2.BlobCommitmentRequest">BlobCommitmentRequest</h3>
        <p>The input for a BlobCommitmentRequest().</p><p>This can be used to construct a BlobHeader.commitment.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>blob</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The blob data to compute the commitment for. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="disperser.v2.BlobInclusionInfo">BlobInclusionInfo</h3>
        <p>BlobInclusionInfo is the information needed to verify the inclusion of a blob in a batch.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>blob_certificate</td>
                  <td><a href="#common.v2.BlobCertificate">common.v2.BlobCertificate</a></td>
                  <td></td>
                  <td><p> </p></td>
                </tr>
              
                <tr>
                  <td>blob_index</td>
                  <td><a href="#uint32">uint32</a></td>
                  <td></td>
                  <td><p>blob_index is the index of the blob in the batch </p></td>
                </tr>
              
                <tr>
                  <td>inclusion_proof</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>inclusion_proof is the inclusion proof of the blob in the batch </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="disperser.v2.BlobStatusReply">BlobStatusReply</h3>
        <p>BlobStatusReply is the reply to a BlobStatusRequest.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>status</td>
                  <td><a href="#disperser.v2.BlobStatus">BlobStatus</a></td>
                  <td></td>
                  <td><p>The status of the blob. </p></td>
                </tr>
              
                <tr>
                  <td>signed_batch</td>
                  <td><a href="#disperser.v2.SignedBatch">SignedBatch</a></td>
                  <td></td>
                  <td><p>The signed batch. Only set if the blob status is GATHERING_SIGNATURES or COMPLETE.
signed_batch and blob_inclusion_info are only set if the blob status is GATHERING_SIGNATURES or COMPLETE.
When blob is in GATHERING_SIGNATURES status, the attestation object in signed_batch contains attestation information
at the point in time. As it gathers more signatures, attestation object will be updated according to the latest attestation status.
The client can use this intermediate attestation to verify a blob if it has gathered enough signatures. 
Otherwise, it should should poll the GetBlobStatus API until the desired level of attestation has been gathered or status is COMPLETE.
When blob is in COMPLETE status, the attestation object in signed_batch contains the final attestation information.
If the final attestation does not meet the client&#39;s requirement, the client should try a new dispersal. </p></td>
                </tr>
              
                <tr>
                  <td>blob_inclusion_info</td>
                  <td><a href="#disperser.v2.BlobInclusionInfo">BlobInclusionInfo</a></td>
                  <td></td>
                  <td><p>BlobInclusionInfo is the information needed to verify the inclusion of a blob in a batch.
Only set if the blob status is GATHERING_SIGNATURES or COMPLETE. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="disperser.v2.BlobStatusRequest">BlobStatusRequest</h3>
        <p>BlobStatusRequest is used to query the status of a blob.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>blob_key</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The unique identifier for the blob. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="disperser.v2.DisperseBlobReply">DisperseBlobReply</h3>
        <p>A reply to a DisperseBlob request.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>result</td>
                  <td><a href="#disperser.v2.BlobStatus">BlobStatus</a></td>
                  <td></td>
                  <td><p>The status of the blob associated with the blob key. </p></td>
                </tr>
              
                <tr>
                  <td>blob_key</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The unique 32 byte identifier for the blob.

The blob_key is the keccak hash of the rlp serialization of the BlobHeader, as computed here:
https://github.com/Layr-Labs/eigenda/blob/0f14d1c90b86d29c30ff7e92cbadf2762c47f402/core/v2/serialization.go#L30
The blob_key must thus be unique for every request, even if the same blob is being dispersed.
Meaning the blob_header must be different for each request.

Note that attempting to disperse a blob with the same blob key as a previously dispersed blob may cause
the disperser to reject the blob (DisperseBlob() RPC will return an error). </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="disperser.v2.DisperseBlobRequest">DisperseBlobRequest</h3>
        <p>A request to disperse a blob.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>blob</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The blob to be dispersed.

The size of this byte array may be any size as long as it does not exceed the maximum length of 16MiB.
While the data being dispersed is only required to be greater than 0 bytes, the blob size charged against the 
payment method will be rounded up to the nearest multiple of `minNumSymbols` defined by the payment vault contract 
(https://github.com/Layr-Labs/eigenda/blob/1430d56258b4e814b388e497320fd76354bfb478/contracts/src/payments/PaymentVaultStorage.sol#L9).

Every 32 bytes of data is interpreted as an integer in big endian format where the lower address has more
significant bits. The integer must stay in the valid range to be interpreted as a field element on the bn254 curve.
The valid range is 0 &lt;= x &lt; 21888242871839275222246405745257275088548364400416034343698204186575808495617.
If any one of the 32 bytes elements is outside the range, the whole request is deemed as invalid, and rejected. </p></td>
                </tr>
              
                <tr>
                  <td>blob_header</td>
                  <td><a href="#common.v2.BlobHeader">common.v2.BlobHeader</a></td>
                  <td></td>
                  <td><p>The header contains metadata about the blob.

This header can be thought of as an &#34;eigenDA tx&#34;, in that it plays a purpose similar to an eth_tx to disperse a
4844 blob. Note that a call to DisperseBlob requires the blob and the blobHeader, which is similar to how
dispersing a blob to ethereum requires sending a tx whose data contains the hash of the kzg commit of the blob,
which is dispersed separately. </p></td>
                </tr>
              
                <tr>
                  <td>signature</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>signature over keccak hash of the blob_header that can be verified by blob_header.payment_header.account_id </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="disperser.v2.GetPaymentStateReply">GetPaymentStateReply</h3>
        <p>GetPaymentStateReply contains the payment state of an account.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>payment_global_params</td>
                  <td><a href="#disperser.v2.PaymentGlobalParams">PaymentGlobalParams</a></td>
                  <td></td>
                  <td><p>global payment vault parameters </p></td>
                </tr>
              
                <tr>
                  <td>period_records</td>
                  <td><a href="#disperser.v2.PeriodRecord">PeriodRecord</a></td>
                  <td>repeated</td>
                  <td><p>off-chain account reservation usage records </p></td>
                </tr>
              
                <tr>
                  <td>reservation</td>
                  <td><a href="#disperser.v2.Reservation">Reservation</a></td>
                  <td></td>
                  <td><p>on-chain account reservation setting </p></td>
                </tr>
              
                <tr>
                  <td>cumulative_payment</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>off-chain on-demand payment usage </p></td>
                </tr>
              
                <tr>
                  <td>onchain_cumulative_payment</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>on-chain on-demand payment deposited </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="disperser.v2.GetPaymentStateRequest">GetPaymentStateRequest</h3>
        <p>GetPaymentStateRequest contains parameters to query the payment state of an account.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>account_id</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The ID of the account being queried. This account ID is an eth wallet address of the user. </p></td>
                </tr>
              
                <tr>
                  <td>signature</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>Signature over the account ID </p></td>
                </tr>
              
                <tr>
                  <td>timestamp</td>
                  <td><a href="#uint32">uint32</a></td>
                  <td></td>
                  <td><p>Timestamp of the request in seconds since the Unix epoch. If too far out of sync with the server&#39;s clock,
request may be rejected. </p></td>
                </tr>
              
                <tr>
                  <td>nonce</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>A client-generated nonce to ensure the request is unique. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="disperser.v2.PaymentGlobalParams">PaymentGlobalParams</h3>
        <p>Global constant parameters defined by the payment vault.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>global_symbols_per_second</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>Global ratelimit for on-demand dispersals </p></td>
                </tr>
              
                <tr>
                  <td>min_num_symbols</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>Minimum number of symbols accounted for all dispersals </p></td>
                </tr>
              
                <tr>
                  <td>price_per_symbol</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>Price charged per symbol for on-demand dispersals </p></td>
                </tr>
              
                <tr>
                  <td>reservation_window</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>Reservation window for all reservations </p></td>
                </tr>
              
                <tr>
                  <td>on_demand_quorum_numbers</td>
                  <td><a href="#uint32">uint32</a></td>
                  <td>repeated</td>
                  <td><p>quorums allowed to make on-demand dispersals </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="disperser.v2.PeriodRecord">PeriodRecord</h3>
        <p>PeriodRecord is the usage record of an account in a bin. The API should return the active bin</p><p>record and the subsequent two records that contains potential overflows.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>index</td>
                  <td><a href="#uint32">uint32</a></td>
                  <td></td>
                  <td><p>Period index of the reservation </p></td>
                </tr>
              
                <tr>
                  <td>usage</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>symbol usage recorded </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="disperser.v2.Reservation">Reservation</h3>
        <p>Reservation parameters of an account, used to determine the rate limit for the account.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>symbols_per_second</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>rate limit for the account </p></td>
                </tr>
              
                <tr>
                  <td>start_timestamp</td>
                  <td><a href="#uint32">uint32</a></td>
                  <td></td>
                  <td><p>start timestamp of the reservation </p></td>
                </tr>
              
                <tr>
                  <td>end_timestamp</td>
                  <td><a href="#uint32">uint32</a></td>
                  <td></td>
                  <td><p>end timestamp of the reservation </p></td>
                </tr>
              
                <tr>
                  <td>quorum_numbers</td>
                  <td><a href="#uint32">uint32</a></td>
                  <td>repeated</td>
                  <td><p>quorums allowed to make reserved dispersals </p></td>
                </tr>
              
                <tr>
                  <td>quorum_splits</td>
                  <td><a href="#uint32">uint32</a></td>
                  <td>repeated</td>
                  <td><p>quorum splits describes how the payment is split among the quorums </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="disperser.v2.SignedBatch">SignedBatch</h3>
        <p>SignedBatch is a batch of blobs with a signature.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>header</td>
                  <td><a href="#common.v2.BatchHeader">common.v2.BatchHeader</a></td>
                  <td></td>
                  <td><p>header contains metadata about the batch </p></td>
                </tr>
              
                <tr>
                  <td>attestation</td>
                  <td><a href="#disperser.v2.Attestation">Attestation</a></td>
                  <td></td>
                  <td><p>attestation on the batch </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      
        <h3 id="disperser.v2.BlobStatus">BlobStatus</h3>
        <p>BlobStatus represents the status of a blob.</p><p>The status of a blob is updated as the blob is processed by the disperser.</p><p>The status of a blob can be queried by the client using the GetBlobStatus API.</p><p>Intermediate states are states that the blob can be in while being processed, and it can be updated to a different state:</p><p>- QUEUED</p><p>- ENCODED</p><p>- GATHERING_SIGNATURES</p><p>Terminal states are states that will not be updated to a different state:</p><p>- UNKNOWN</p><p>- COMPLETE</p><p>- FAILED</p>
        <table class="enum-table">
          <thead>
            <tr><td>Name</td><td>Number</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>UNKNOWN</td>
                <td>0</td>
                <td><p>UNKNOWN means that the status of the blob is unknown.
This is a catch all and should not be encountered absent a bug.

This status is functionally equivalent to FAILED, but is used to indicate that the failure is due to an
unanticipated bug.</p></td>
              </tr>
            
              <tr>
                <td>QUEUED</td>
                <td>1</td>
                <td><p>QUEUED means that the blob has been queued by the disperser for processing.
The DisperseBlob API is asynchronous, meaning that after request validation, but before any processing,
the blob is stored in a queue of some sort, and a response immediately returned to the client.</p></td>
              </tr>
            
              <tr>
                <td>ENCODED</td>
                <td>2</td>
                <td><p>ENCODED means that the blob has been Reed-Solomon encoded into chunks and is ready to be dispersed to DA Nodes.</p></td>
              </tr>
            
              <tr>
                <td>GATHERING_SIGNATURES</td>
                <td>3</td>
                <td><p>GATHERING_SIGNATURES means that the blob chunks are currently actively being transmitted to validators,
and in doing so requesting that the validators sign to acknowledge receipt of the blob.
Requests that timeout or receive errors are resubmitted to DA nodes for some period of time set by the disperser,
after which the BlobStatus becomes COMPLETE.</p></td>
              </tr>
            
              <tr>
                <td>COMPLETE</td>
                <td>4</td>
                <td><p>COMPLETE means the blob has been dispersed to DA nodes, and the GATHERING_SIGNATURES period of time has completed.
This status does not guarantee any signer percentage, so a client should check that the signature has met
its required threshold, and resubmit a new blob dispersal request if not.</p></td>
              </tr>
            
              <tr>
                <td>FAILED</td>
                <td>5</td>
                <td><p>FAILED means that the blob has failed permanently. Note that this is a terminal state, and in order to
retry the blob, the client must submit the blob again (blob key is required to be unique).</p></td>
              </tr>
            
          </tbody>
        </table>
      

      

      
        <h3 id="disperser.v2.Disperser">Disperser</h3>
        <p>Disperser defines the public APIs for dispersing blobs.</p>
        <table class="enum-table">
          <thead>
            <tr><td>Method Name</td><td>Request Type</td><td>Response Type</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>DisperseBlob</td>
                <td><a href="#disperser.v2.DisperseBlobRequest">DisperseBlobRequest</a></td>
                <td><a href="#disperser.v2.DisperseBlobReply">DisperseBlobReply</a></td>
                <td><p>DisperseBlob accepts blob to disperse from clients.
This executes the dispersal asynchronously, i.e. it returns once the request
is accepted. The client could use GetBlobStatus() API to poll the the
processing status of the blob.</p></td>
              </tr>
            
              <tr>
                <td>GetBlobStatus</td>
                <td><a href="#disperser.v2.BlobStatusRequest">BlobStatusRequest</a></td>
                <td><a href="#disperser.v2.BlobStatusReply">BlobStatusReply</a></td>
                <td><p>GetBlobStatus is meant to be polled for the blob status.</p></td>
              </tr>
            
              <tr>
                <td>GetBlobCommitment</td>
                <td><a href="#disperser.v2.BlobCommitmentRequest">BlobCommitmentRequest</a></td>
                <td><a href="#disperser.v2.BlobCommitmentReply">BlobCommitmentReply</a></td>
                <td><p>GetBlobCommitment is a utility method that calculates commitment for a blob payload.
It is provided to help clients who are trying to construct a DisperseBlobRequest.blob_header
and don&#39;t have the ability to calculate the commitment themselves (expensive operation which requires SRS points).

For an example usage, see how our disperser_client makes a call to this endpoint when it doesn&#39;t have a local prover:
https://github.com/Layr-Labs/eigenda/blob/6059c6a068298d11c41e50f5bcd208d0da44906a/api/clients/v2/disperser_client.go#L166</p></td>
              </tr>
            
              <tr>
                <td>GetPaymentState</td>
                <td><a href="#disperser.v2.GetPaymentStateRequest">GetPaymentStateRequest</a></td>
                <td><a href="#disperser.v2.GetPaymentStateReply">GetPaymentStateReply</a></td>
                <td><p>GetPaymentState is a utility method to get the payment state of a given account, at a given disperser.
EigenDA&#39;s payment system for v2 is currently centralized, meaning that each disperser does its own accounting.
A client wanting to disperse a blob would thus need to synchronize its local accounting state with that of the disperser.
That typically only needs to be done once, and the state can be updated locally as the client disperses blobs.
The accounting rules are simple and can be updated locally, but periodic checks with the disperser can&#39;t hurt.

For an example usage, see how our disperser_client makes a call to this endpoint to populate its local accountant struct:
https://github.com/Layr-Labs/eigenda/blob/6059c6a068298d11c41e50f5bcd208d0da44906a/api/clients/v2/disperser_client.go#L298</p></td>
              </tr>
            
          </tbody>
        </table>

        
    

    <h2 id="scalar-value-types">Scalar Value Types</h2>
    <table class="scalar-value-types-table">
      <thead>
        <tr><td>.proto Type</td><td>Notes</td><td>C++</td><td>Java</td><td>Python</td><td>Go</td><td>C#</td><td>PHP</td><td>Ruby</td></tr>
      </thead>
      <tbody>
        
          <tr id="double">
            <td>double</td>
            <td></td>
            <td>double</td>
            <td>double</td>
            <td>float</td>
            <td>float64</td>
            <td>double</td>
            <td>float</td>
            <td>Float</td>
          </tr>
        
          <tr id="float">
            <td>float</td>
            <td></td>
            <td>float</td>
            <td>float</td>
            <td>float</td>
            <td>float32</td>
            <td>float</td>
            <td>float</td>
            <td>Float</td>
          </tr>
        
          <tr id="int32">
            <td>int32</td>
            <td>Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.</td>
            <td>int32</td>
            <td>int</td>
            <td>int</td>
            <td>int32</td>
            <td>int</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="int64">
            <td>int64</td>
            <td>Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.</td>
            <td>int64</td>
            <td>long</td>
            <td>int/long</td>
            <td>int64</td>
            <td>long</td>
            <td>integer/string</td>
            <td>Bignum</td>
          </tr>
        
          <tr id="uint32">
            <td>uint32</td>
            <td>Uses variable-length encoding.</td>
            <td>uint32</td>
            <td>int</td>
            <td>int/long</td>
            <td>uint32</td>
            <td>uint</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="uint64">
            <td>uint64</td>
            <td>Uses variable-length encoding.</td>
            <td>uint64</td>
            <td>long</td>
            <td>int/long</td>
            <td>uint64</td>
            <td>ulong</td>
            <td>integer/string</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="sint32">
            <td>sint32</td>
            <td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.</td>
            <td>int32</td>
            <td>int</td>
            <td>int</td>
            <td>int32</td>
            <td>int</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="sint64">
            <td>sint64</td>
            <td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.</td>
            <td>int64</td>
            <td>long</td>
            <td>int/long</td>
            <td>int64</td>
            <td>long</td>
            <td>integer/string</td>
            <td>Bignum</td>
          </tr>
        
          <tr id="fixed32">
            <td>fixed32</td>
            <td>Always four bytes. More efficient than uint32 if values are often greater than 2^28.</td>
            <td>uint32</td>
            <td>int</td>
            <td>int</td>
            <td>uint32</td>
            <td>uint</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="fixed64">
            <td>fixed64</td>
            <td>Always eight bytes. More efficient than uint64 if values are often greater than 2^56.</td>
            <td>uint64</td>
            <td>long</td>
            <td>int/long</td>
            <td>uint64</td>
            <td>ulong</td>
            <td>integer/string</td>
            <td>Bignum</td>
          </tr>
        
          <tr id="sfixed32">
            <td>sfixed32</td>
            <td>Always four bytes.</td>
            <td>int32</td>
            <td>int</td>
            <td>int</td>
            <td>int32</td>
            <td>int</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="sfixed64">
            <td>sfixed64</td>
            <td>Always eight bytes.</td>
            <td>int64</td>
            <td>long</td>
            <td>int/long</td>
            <td>int64</td>
            <td>long</td>
            <td>integer/string</td>
            <td>Bignum</td>
          </tr>
        
          <tr id="bool">
            <td>bool</td>
            <td></td>
            <td>bool</td>
            <td>boolean</td>
            <td>boolean</td>
            <td>bool</td>
            <td>bool</td>
            <td>boolean</td>
            <td>TrueClass/FalseClass</td>
          </tr>
        
          <tr id="string">
            <td>string</td>
            <td>A string must always contain UTF-8 encoded or 7-bit ASCII text.</td>
            <td>string</td>
            <td>String</td>
            <td>str/unicode</td>
            <td>string</td>
            <td>string</td>
            <td>string</td>
            <td>String (UTF-8)</td>
          </tr>
        
          <tr id="bytes">
            <td>bytes</td>
            <td>May contain any arbitrary sequence of bytes.</td>
            <td>string</td>
            <td>ByteString</td>
            <td>str</td>
            <td>[]byte</td>
            <td>ByteString</td>
            <td>string</td>
            <td>String (ASCII-8BIT)</td>
          </tr>
        
      </tbody>
    </table>
  </body>
</html>

