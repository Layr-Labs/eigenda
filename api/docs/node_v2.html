<!DOCTYPE html>

<html>
  <head>
    <title>Protocol Documentation</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>
    <style>
      body {
        width: 60em;
        margin: 1em auto;
        color: #222;
        font-family: "Ubuntu", sans-serif;
        padding-bottom: 4em;
      }

      h1 {
        font-weight: normal;
        border-bottom: 1px solid #aaa;
        padding-bottom: 0.5ex;
      }

      h2 {
        border-bottom: 1px solid #aaa;
        padding-bottom: 0.5ex;
        margin: 1.5em 0;
      }

      h3 {
        font-weight: normal;
        border-bottom: 1px solid #aaa;
        padding-bottom: 0.5ex;
      }

      a {
        text-decoration: none;
        color: #567e25;
      }

      table {
        width: 100%;
        font-size: 80%;
        border-collapse: collapse;
      }

      thead {
        font-weight: 700;
        background-color: #dcdcdc;
      }

      tbody tr:nth-child(even) {
        background-color: #fbfbfb;
      }

      td {
        border: 1px solid #ccc;
        padding: 0.5ex 2ex;
      }

      td p {
        text-indent: 1em;
        margin: 0;
      }

      td p:nth-child(1) {
        text-indent: 0;  
      }

       
      .field-table td:nth-child(1) {  
        width: 10em;
      }
      .field-table td:nth-child(2) {  
        width: 10em;
      }
      .field-table td:nth-child(3) {  
        width: 6em;
      }
      .field-table td:nth-child(4) {  
        width: auto;
      }

       
      .extension-table td:nth-child(1) {  
        width: 10em;
      }
      .extension-table td:nth-child(2) {  
        width: 10em;
      }
      .extension-table td:nth-child(3) {  
        width: 10em;
      }
      .extension-table td:nth-child(4) {  
        width: 5em;
      }
      .extension-table td:nth-child(5) {  
        width: auto;
      }

       
      .enum-table td:nth-child(1) {  
        width: 10em;
      }
      .enum-table td:nth-child(2) {  
        width: 10em;
      }
      .enum-table td:nth-child(3) {  
        width: auto;
      }

       
      .scalar-value-types-table tr {
        height: 3em;
      }

       
      #toc-container ul {
        list-style-type: none;
        padding-left: 1em;
        line-height: 180%;
        margin: 0;
      }
      #toc > li > a {
        font-weight: bold;
      }

       
      .file-heading {
        width: 100%;
        display: table;
        border-bottom: 1px solid #aaa;
        margin: 4em 0 1.5em 0;
      }
      .file-heading h2 {
        border: none;
        display: table-cell;
      }
      .file-heading a {
        text-align: right;
        display: table-cell;
      }

       
      .badge {
        width: 1.6em;
        height: 1.6em;
        display: inline-block;

        line-height: 1.6em;
        text-align: center;
        font-weight: bold;
        font-size: 60%;

        color: #89ba48;
        background-color: #dff0c8;

        margin: 0.5ex 1em 0.5ex -1em;
        border: 1px solid #fbfbfb;
        border-radius: 1ex;
      }
    </style>

    
    <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
  </head>

  <body>

    <h1 id="title">Protocol Documentation</h1>

    <h2>Table of Contents</h2>

    <div id="toc-container">
      <ul id="toc">
        
          
          <li>
            <a href="#node%2fv2%2fnode_v2.proto">node/v2/node_v2.proto</a>
            <ul>
              
                <li>
                  <a href="#node.v2.GetChunksReply"><span class="badge">M</span>GetChunksReply</a>
                </li>
              
                <li>
                  <a href="#node.v2.GetChunksRequest"><span class="badge">M</span>GetChunksRequest</a>
                </li>
              
                <li>
                  <a href="#node.v2.GetNodeInfoReply"><span class="badge">M</span>GetNodeInfoReply</a>
                </li>
              
                <li>
                  <a href="#node.v2.GetNodeInfoRequest"><span class="badge">M</span>GetNodeInfoRequest</a>
                </li>
              
                <li>
                  <a href="#node.v2.StoreChunksReply"><span class="badge">M</span>StoreChunksReply</a>
                </li>
              
                <li>
                  <a href="#node.v2.StoreChunksRequest"><span class="badge">M</span>StoreChunksRequest</a>
                </li>
              
              
              
              
                <li>
                  <a href="#node.v2.Dispersal"><span class="badge">S</span>Dispersal</a>
                </li>
              
                <li>
                  <a href="#node.v2.Retrieval"><span class="badge">S</span>Retrieval</a>
                </li>
              
            </ul>
          </li>
        
        <li><a href="#scalar-value-types">Scalar Value Types</a></li>
      </ul>
    </div>

    
      
      <div class="file-heading">
        <h2 id="node/v2/node_v2.proto">node/v2/node_v2.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="node.v2.GetChunksReply">GetChunksReply</h3>
        <p>The response to the GetChunks() RPC.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>chunks</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td>repeated</td>
                  <td><p>All chunks the Node is storing for the requested blob per RetrieveChunksRequest. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="node.v2.GetChunksRequest">GetChunksRequest</h3>
        <p>The parameter for the GetChunks() RPC.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>blob_key</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The unique identifier for the blob the chunks are being requested for.
The blob_key is the keccak hash of the rlp serialization of the BlobHeader, as computed here:
https://github.com/Layr-Labs/eigenda/blob/0f14d1c90b86d29c30ff7e92cbadf2762c47f402/core/v2/serialization.go#L30 </p></td>
                </tr>
              
                <tr>
                  <td>quorum_id</td>
                  <td><a href="#uint32">uint32</a></td>
                  <td></td>
                  <td><p>Which quorum of the blob to retrieve for (note: a blob can have multiple
quorums and the chunks for different quorums at a Node can be different).
The ID must be in range [0, 254]. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="node.v2.GetNodeInfoReply">GetNodeInfoReply</h3>
        <p>Node info reply</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>semver</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The version of the node. </p></td>
                </tr>
              
                <tr>
                  <td>arch</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The architecture of the node. </p></td>
                </tr>
              
                <tr>
                  <td>os</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The operating system of the node. </p></td>
                </tr>
              
                <tr>
                  <td>num_cpu</td>
                  <td><a href="#uint32">uint32</a></td>
                  <td></td>
                  <td><p>The number of CPUs on the node. </p></td>
                </tr>
              
                <tr>
                  <td>mem_bytes</td>
                  <td><a href="#uint64">uint64</a></td>
                  <td></td>
                  <td><p>The amount of memory on the node in bytes. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="node.v2.GetNodeInfoRequest">GetNodeInfoRequest</h3>
        <p>The parameter for the GetNodeInfo() RPC.</p>

        

        
      
        <h3 id="node.v2.StoreChunksReply">StoreChunksReply</h3>
        <p>StoreChunksReply is the message type used to respond to a StoreChunks() RPC.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>signature</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>a custody signature of the received chunks </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="node.v2.StoreChunksRequest">StoreChunksRequest</h3>
        <p>Request that the Node store a batch of chunks.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>batch</td>
                  <td><a href="#common.v2.Batch">common.v2.Batch</a></td>
                  <td></td>
                  <td><p>batch of blobs to store </p></td>
                </tr>
              
                <tr>
                  <td>disperserID</td>
                  <td><a href="#uint32">uint32</a></td>
                  <td></td>
                  <td><p>ID of the disperser that is requesting the storage of the batch. </p></td>
                </tr>
              
                <tr>
                  <td>signature</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>Signature using the disperser&#39;s ECDSA key over keccak hash of the batch. The purpose of this signature
is to prevent hooligans from tricking DA nodes into storing data that they shouldn&#39;t be storing.

Algorithm for computing the hash is as follows. All integer values are serialized in big-endian order (unsigned).
A reference implementation (golang) can be found at
https://github.com/Layr-Labs/eigenda/blob/master/disperser/auth/request_signing.go

1. digest batch.BatchHeader.BatchRoot
2. digest batch.BatchHeader.ReferenceBlockNumber (8 bytes, unsigned big endian)
3. for each certificate in batch.BlobCertificates:
  a. digest certificate.BlobHeader.Version (4 bytes, unsigned big endian)
  b. for each quorum_number in certificate.BlobHeader.QuorumNumbers:
    i. digest quorum_number (4 bytes, unsigned big endian)
  c. digest certificate.BlobHeader.Commitment.Commitment
  d. digest certificate.BlobHeader.Commitment.LengthCommitment
  e. digest certificate.BlobHeader.Commitment.LengthProof
  f. digest certificate.BlobHeader.Commitment.Length (4 bytes, unsigned big endian)
  g. digest certificate.BlobHeader.PaymentHeader.AccountId
  h. digest certificate.BlobHeader.PaymentHeader.ReservationPeriod (4 bytes, unsigned big endian)
  i. digest certificate.BlobHeader.PaymentHeader.CumulativePayment
  j. digest certificate.BlobHeader.PaymentHeader.Salt (4 bytes, unsigned big endian)
  k. digest certificate.BlobHeader.Signature
  l. for each relay in certificate.Relays:
    i. digest relay (4 bytes, unsigned big endian)
4. digest disperserID (4 bytes, unsigned big endian)

Note that this signature is not included in the hash for obvious reasons. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
        <h3 id="node.v2.Dispersal">Dispersal</h3>
        <p>Dispersal is utilized to disperse chunk data.</p>
        <table class="enum-table">
          <thead>
            <tr><td>Method Name</td><td>Request Type</td><td>Response Type</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>StoreChunks</td>
                <td><a href="#node.v2.StoreChunksRequest">StoreChunksRequest</a></td>
                <td><a href="#node.v2.StoreChunksReply">StoreChunksReply</a></td>
                <td><p>StoreChunks instructs the validator to store a batch of chunks. This call blocks until the validator
either acquires the chunks or the validator determines that it is unable to acquire the chunks. If
the validator is able to acquire and validate the chunks, it returns a signature over the batch header.
This RPC describes which chunks the validator should store but does not contain that chunk data. The validator
is expected to fetch the chunk data from one of the relays that is in possession of the chunk.</p></td>
              </tr>
            
              <tr>
                <td>GetNodeInfo</td>
                <td><a href="#node.v2.GetNodeInfoRequest">GetNodeInfoRequest</a></td>
                <td><a href="#node.v2.GetNodeInfoReply">GetNodeInfoReply</a></td>
                <td><p>GetNodeInfo fetches metadata about the node.</p></td>
              </tr>
            
          </tbody>
        </table>

        
        <h3 id="node.v2.Retrieval">Retrieval</h3>
        <p>Retrieval is utilized to retrieve chunk data.</p>
        <table class="enum-table">
          <thead>
            <tr><td>Method Name</td><td>Request Type</td><td>Response Type</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>GetChunks</td>
                <td><a href="#node.v2.GetChunksRequest">GetChunksRequest</a></td>
                <td><a href="#node.v2.GetChunksReply">GetChunksReply</a></td>
                <td><p>GetChunks retrieves the chunks for a blob custodied at the Node. Note that where possible, it is generally
faster to retrieve chunks from the relay service if that service is available.</p></td>
              </tr>
            
              <tr>
                <td>GetNodeInfo</td>
                <td><a href="#node.v2.GetNodeInfoRequest">GetNodeInfoRequest</a></td>
                <td><a href="#node.v2.GetNodeInfoReply">GetNodeInfoReply</a></td>
                <td><p>Retrieve node info metadata</p></td>
              </tr>
            
          </tbody>
        </table>

        
    

    <h2 id="scalar-value-types">Scalar Value Types</h2>
    <table class="scalar-value-types-table">
      <thead>
        <tr><td>.proto Type</td><td>Notes</td><td>C++</td><td>Java</td><td>Python</td><td>Go</td><td>C#</td><td>PHP</td><td>Ruby</td></tr>
      </thead>
      <tbody>
        
          <tr id="double">
            <td>double</td>
            <td></td>
            <td>double</td>
            <td>double</td>
            <td>float</td>
            <td>float64</td>
            <td>double</td>
            <td>float</td>
            <td>Float</td>
          </tr>
        
          <tr id="float">
            <td>float</td>
            <td></td>
            <td>float</td>
            <td>float</td>
            <td>float</td>
            <td>float32</td>
            <td>float</td>
            <td>float</td>
            <td>Float</td>
          </tr>
        
          <tr id="int32">
            <td>int32</td>
            <td>Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.</td>
            <td>int32</td>
            <td>int</td>
            <td>int</td>
            <td>int32</td>
            <td>int</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="int64">
            <td>int64</td>
            <td>Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.</td>
            <td>int64</td>
            <td>long</td>
            <td>int/long</td>
            <td>int64</td>
            <td>long</td>
            <td>integer/string</td>
            <td>Bignum</td>
          </tr>
        
          <tr id="uint32">
            <td>uint32</td>
            <td>Uses variable-length encoding.</td>
            <td>uint32</td>
            <td>int</td>
            <td>int/long</td>
            <td>uint32</td>
            <td>uint</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="uint64">
            <td>uint64</td>
            <td>Uses variable-length encoding.</td>
            <td>uint64</td>
            <td>long</td>
            <td>int/long</td>
            <td>uint64</td>
            <td>ulong</td>
            <td>integer/string</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="sint32">
            <td>sint32</td>
            <td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.</td>
            <td>int32</td>
            <td>int</td>
            <td>int</td>
            <td>int32</td>
            <td>int</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="sint64">
            <td>sint64</td>
            <td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.</td>
            <td>int64</td>
            <td>long</td>
            <td>int/long</td>
            <td>int64</td>
            <td>long</td>
            <td>integer/string</td>
            <td>Bignum</td>
          </tr>
        
          <tr id="fixed32">
            <td>fixed32</td>
            <td>Always four bytes. More efficient than uint32 if values are often greater than 2^28.</td>
            <td>uint32</td>
            <td>int</td>
            <td>int</td>
            <td>uint32</td>
            <td>uint</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="fixed64">
            <td>fixed64</td>
            <td>Always eight bytes. More efficient than uint64 if values are often greater than 2^56.</td>
            <td>uint64</td>
            <td>long</td>
            <td>int/long</td>
            <td>uint64</td>
            <td>ulong</td>
            <td>integer/string</td>
            <td>Bignum</td>
          </tr>
        
          <tr id="sfixed32">
            <td>sfixed32</td>
            <td>Always four bytes.</td>
            <td>int32</td>
            <td>int</td>
            <td>int</td>
            <td>int32</td>
            <td>int</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="sfixed64">
            <td>sfixed64</td>
            <td>Always eight bytes.</td>
            <td>int64</td>
            <td>long</td>
            <td>int/long</td>
            <td>int64</td>
            <td>long</td>
            <td>integer/string</td>
            <td>Bignum</td>
          </tr>
        
          <tr id="bool">
            <td>bool</td>
            <td></td>
            <td>bool</td>
            <td>boolean</td>
            <td>boolean</td>
            <td>bool</td>
            <td>bool</td>
            <td>boolean</td>
            <td>TrueClass/FalseClass</td>
          </tr>
        
          <tr id="string">
            <td>string</td>
            <td>A string must always contain UTF-8 encoded or 7-bit ASCII text.</td>
            <td>string</td>
            <td>String</td>
            <td>str/unicode</td>
            <td>string</td>
            <td>string</td>
            <td>string</td>
            <td>String (UTF-8)</td>
          </tr>
        
          <tr id="bytes">
            <td>bytes</td>
            <td>May contain any arbitrary sequence of bytes.</td>
            <td>string</td>
            <td>ByteString</td>
            <td>str</td>
            <td>[]byte</td>
            <td>ByteString</td>
            <td>string</td>
            <td>String (ASCII-8BIT)</td>
          </tr>
        
      </tbody>
    </table>
  </body>
</html>

