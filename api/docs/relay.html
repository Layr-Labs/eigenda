<!DOCTYPE html>

<html>
  <head>
    <title>Protocol Documentation</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>
    <style>
      body {
        width: 60em;
        margin: 1em auto;
        color: #222;
        font-family: "Ubuntu", sans-serif;
        padding-bottom: 4em;
      }

      h1 {
        font-weight: normal;
        border-bottom: 1px solid #aaa;
        padding-bottom: 0.5ex;
      }

      h2 {
        border-bottom: 1px solid #aaa;
        padding-bottom: 0.5ex;
        margin: 1.5em 0;
      }

      h3 {
        font-weight: normal;
        border-bottom: 1px solid #aaa;
        padding-bottom: 0.5ex;
      }

      a {
        text-decoration: none;
        color: #567e25;
      }

      table {
        width: 100%;
        font-size: 80%;
        border-collapse: collapse;
      }

      thead {
        font-weight: 700;
        background-color: #dcdcdc;
      }

      tbody tr:nth-child(even) {
        background-color: #fbfbfb;
      }

      td {
        border: 1px solid #ccc;
        padding: 0.5ex 2ex;
      }

      td p {
        text-indent: 1em;
        margin: 0;
      }

      td p:nth-child(1) {
        text-indent: 0;  
      }

       
      .field-table td:nth-child(1) {  
        width: 10em;
      }
      .field-table td:nth-child(2) {  
        width: 10em;
      }
      .field-table td:nth-child(3) {  
        width: 6em;
      }
      .field-table td:nth-child(4) {  
        width: auto;
      }

       
      .extension-table td:nth-child(1) {  
        width: 10em;
      }
      .extension-table td:nth-child(2) {  
        width: 10em;
      }
      .extension-table td:nth-child(3) {  
        width: 10em;
      }
      .extension-table td:nth-child(4) {  
        width: 5em;
      }
      .extension-table td:nth-child(5) {  
        width: auto;
      }

       
      .enum-table td:nth-child(1) {  
        width: 10em;
      }
      .enum-table td:nth-child(2) {  
        width: 10em;
      }
      .enum-table td:nth-child(3) {  
        width: auto;
      }

       
      .scalar-value-types-table tr {
        height: 3em;
      }

       
      #toc-container ul {
        list-style-type: none;
        padding-left: 1em;
        line-height: 180%;
        margin: 0;
      }
      #toc > li > a {
        font-weight: bold;
      }

       
      .file-heading {
        width: 100%;
        display: table;
        border-bottom: 1px solid #aaa;
        margin: 4em 0 1.5em 0;
      }
      .file-heading h2 {
        border: none;
        display: table-cell;
      }
      .file-heading a {
        text-align: right;
        display: table-cell;
      }

       
      .badge {
        width: 1.6em;
        height: 1.6em;
        display: inline-block;

        line-height: 1.6em;
        text-align: center;
        font-weight: bold;
        font-size: 60%;

        color: #89ba48;
        background-color: #dff0c8;

        margin: 0.5ex 1em 0.5ex -1em;
        border: 1px solid #fbfbfb;
        border-radius: 1ex;
      }
    </style>

    
    <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
  </head>

  <body>

    <h1 id="title">Protocol Documentation</h1>

    <h2>Table of Contents</h2>

    <div id="toc-container">
      <ul id="toc">
        
          
          <li>
            <a href="#relay%2frelay.proto">relay/relay.proto</a>
            <ul>
              
                <li>
                  <a href="#node.ChunkRequest"><span class="badge">M</span>ChunkRequest</a>
                </li>
              
                <li>
                  <a href="#node.ChunkRequestByIndex"><span class="badge">M</span>ChunkRequestByIndex</a>
                </li>
              
                <li>
                  <a href="#node.ChunkRequestByRange"><span class="badge">M</span>ChunkRequestByRange</a>
                </li>
              
                <li>
                  <a href="#node.GetBlobReply"><span class="badge">M</span>GetBlobReply</a>
                </li>
              
                <li>
                  <a href="#node.GetBlobRequest"><span class="badge">M</span>GetBlobRequest</a>
                </li>
              
                <li>
                  <a href="#node.GetChunksReply"><span class="badge">M</span>GetChunksReply</a>
                </li>
              
                <li>
                  <a href="#node.GetChunksRequest"><span class="badge">M</span>GetChunksRequest</a>
                </li>
              
              
              
              
                <li>
                  <a href="#node.Relay"><span class="badge">S</span>Relay</a>
                </li>
              
            </ul>
          </li>
        
        <li><a href="#scalar-value-types">Scalar Value Types</a></li>
      </ul>
    </div>

    
      
      <div class="file-heading">
        <h2 id="relay/relay.proto">relay/relay.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="node.ChunkRequest">ChunkRequest</h3>
        <p>A request for chunks within a specific blob. Requests are fulfilled in all-or-nothing fashion. If any of the</p><p>requested chunks are not found or are unable to be fetched, the entire request will fail.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>by_index</td>
                  <td><a href="#node.ChunkRequestByIndex">ChunkRequestByIndex</a></td>
                  <td></td>
                  <td><p>Request chunks by their individual indices. </p></td>
                </tr>
              
                <tr>
                  <td>by_range</td>
                  <td><a href="#node.ChunkRequestByRange">ChunkRequestByRange</a></td>
                  <td></td>
                  <td><p>Request chunks by a range of indices. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="node.ChunkRequestByIndex">ChunkRequestByIndex</h3>
        <p>A request for chunks within a specific blob. Each chunk is requested individually by its index.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>blob_key</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The blob key. </p></td>
                </tr>
              
                <tr>
                  <td>chunk_indices</td>
                  <td><a href="#uint32">uint32</a></td>
                  <td>repeated</td>
                  <td><p>The index of the chunk within the blob. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="node.ChunkRequestByRange">ChunkRequestByRange</h3>
        <p>A request for chunks within a specific blob. Each chunk is requested a range of indices.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>blob_key</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The blob key. </p></td>
                </tr>
              
                <tr>
                  <td>start_index</td>
                  <td><a href="#uint32">uint32</a></td>
                  <td></td>
                  <td><p>The first index to start fetching chunks from. </p></td>
                </tr>
              
                <tr>
                  <td>end_index</td>
                  <td><a href="#uint32">uint32</a></td>
                  <td></td>
                  <td><p>One past the last index to fetch chunks from. Similar semantics to golang slices. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="node.GetBlobReply">GetBlobReply</h3>
        <p>The reply to a GetBlobs request.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>blob</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The blob requested. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="node.GetBlobRequest">GetBlobRequest</h3>
        <p>A request to fetch one or more blobs.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>blob_key</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>The key of the blob to fetch. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="node.GetChunksReply">GetChunksReply</h3>
        <p>The reply to a GetChunks request.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>data</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td>repeated</td>
                  <td><p>The chunks requested. The order of these chunks will be the same as the order of the requested chunks.
data is the raw data of the bundle (i.e. serialized byte array of the frames) </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="node.GetChunksRequest">GetChunksRequest</h3>
        <p>Request chunks from blobs stored by this relay.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>chunk_requests</td>
                  <td><a href="#node.ChunkRequest">ChunkRequest</a></td>
                  <td>repeated</td>
                  <td><p>The chunk requests. Chunks are returned in the same order as they are requested. </p></td>
                </tr>
              
                <tr>
                  <td>operator_id</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>If this is an authenticated request, this should hold the ID of the operator. If this
is an unauthenticated request, this field should be empty. Relays may choose to reject
unauthenticated requests. </p></td>
                </tr>
              
                <tr>
                  <td>operator_signature</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>If this is an authenticated request, this field will hold a BLS signature by the requester
on the hash of this request. Relays may choose to reject unauthenticated requests.

The following describes the schema for computing the hash of this request
This algorithm is implemented in golang using relay.auth.HashGetChunksRequest().

All integers are encoded as unsigned 4 byte big endian values.

Perform a keccak256 hash on the following data in the following order:
1. the operator id
2. for each chunk request:
   a. if the chunk request is a request by index:
      i.   a one byte ASCII representation of the character &#34;i&#34; (aka Ox69)
      ii.  the blob key
      iii. the start index
      iv.  the end index
   b. if the chunk request is a request by range:
      i.   a one byte ASCII representation of the character &#34;r&#34; (aka Ox72)
      ii.  the blob key
      iii. each requested chunk index, in order </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      

      

      
        <h3 id="node.Relay">Relay</h3>
        <p>Relay is a service that provides access to public relay functionality.</p>
        <table class="enum-table">
          <thead>
            <tr><td>Method Name</td><td>Request Type</td><td>Response Type</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>GetBlob</td>
                <td><a href="#node.GetBlobRequest">GetBlobRequest</a></td>
                <td><a href="#node.GetBlobReply">GetBlobReply</a></td>
                <td><p>GetBlob retrieves a blob stored by the relay.</p></td>
              </tr>
            
              <tr>
                <td>GetChunks</td>
                <td><a href="#node.GetChunksRequest">GetChunksRequest</a></td>
                <td><a href="#node.GetChunksReply">GetChunksReply</a></td>
                <td><p>GetChunks retrieves chunks from blobs stored by the relay.</p></td>
              </tr>
            
          </tbody>
        </table>

        
    

    <h2 id="scalar-value-types">Scalar Value Types</h2>
    <table class="scalar-value-types-table">
      <thead>
        <tr><td>.proto Type</td><td>Notes</td><td>C++</td><td>Java</td><td>Python</td><td>Go</td><td>C#</td><td>PHP</td><td>Ruby</td></tr>
      </thead>
      <tbody>
        
          <tr id="double">
            <td>double</td>
            <td></td>
            <td>double</td>
            <td>double</td>
            <td>float</td>
            <td>float64</td>
            <td>double</td>
            <td>float</td>
            <td>Float</td>
          </tr>
        
          <tr id="float">
            <td>float</td>
            <td></td>
            <td>float</td>
            <td>float</td>
            <td>float</td>
            <td>float32</td>
            <td>float</td>
            <td>float</td>
            <td>Float</td>
          </tr>
        
          <tr id="int32">
            <td>int32</td>
            <td>Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.</td>
            <td>int32</td>
            <td>int</td>
            <td>int</td>
            <td>int32</td>
            <td>int</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="int64">
            <td>int64</td>
            <td>Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.</td>
            <td>int64</td>
            <td>long</td>
            <td>int/long</td>
            <td>int64</td>
            <td>long</td>
            <td>integer/string</td>
            <td>Bignum</td>
          </tr>
        
          <tr id="uint32">
            <td>uint32</td>
            <td>Uses variable-length encoding.</td>
            <td>uint32</td>
            <td>int</td>
            <td>int/long</td>
            <td>uint32</td>
            <td>uint</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="uint64">
            <td>uint64</td>
            <td>Uses variable-length encoding.</td>
            <td>uint64</td>
            <td>long</td>
            <td>int/long</td>
            <td>uint64</td>
            <td>ulong</td>
            <td>integer/string</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="sint32">
            <td>sint32</td>
            <td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.</td>
            <td>int32</td>
            <td>int</td>
            <td>int</td>
            <td>int32</td>
            <td>int</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="sint64">
            <td>sint64</td>
            <td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.</td>
            <td>int64</td>
            <td>long</td>
            <td>int/long</td>
            <td>int64</td>
            <td>long</td>
            <td>integer/string</td>
            <td>Bignum</td>
          </tr>
        
          <tr id="fixed32">
            <td>fixed32</td>
            <td>Always four bytes. More efficient than uint32 if values are often greater than 2^28.</td>
            <td>uint32</td>
            <td>int</td>
            <td>int</td>
            <td>uint32</td>
            <td>uint</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="fixed64">
            <td>fixed64</td>
            <td>Always eight bytes. More efficient than uint64 if values are often greater than 2^56.</td>
            <td>uint64</td>
            <td>long</td>
            <td>int/long</td>
            <td>uint64</td>
            <td>ulong</td>
            <td>integer/string</td>
            <td>Bignum</td>
          </tr>
        
          <tr id="sfixed32">
            <td>sfixed32</td>
            <td>Always four bytes.</td>
            <td>int32</td>
            <td>int</td>
            <td>int</td>
            <td>int32</td>
            <td>int</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="sfixed64">
            <td>sfixed64</td>
            <td>Always eight bytes.</td>
            <td>int64</td>
            <td>long</td>
            <td>int/long</td>
            <td>int64</td>
            <td>long</td>
            <td>integer/string</td>
            <td>Bignum</td>
          </tr>
        
          <tr id="bool">
            <td>bool</td>
            <td></td>
            <td>bool</td>
            <td>boolean</td>
            <td>boolean</td>
            <td>bool</td>
            <td>bool</td>
            <td>boolean</td>
            <td>TrueClass/FalseClass</td>
          </tr>
        
          <tr id="string">
            <td>string</td>
            <td>A string must always contain UTF-8 encoded or 7-bit ASCII text.</td>
            <td>string</td>
            <td>String</td>
            <td>str/unicode</td>
            <td>string</td>
            <td>string</td>
            <td>string</td>
            <td>String (UTF-8)</td>
          </tr>
        
          <tr id="bytes">
            <td>bytes</td>
            <td>May contain any arbitrary sequence of bytes.</td>
            <td>string</td>
            <td>ByteString</td>
            <td>str</td>
            <td>[]byte</td>
            <td>ByteString</td>
            <td>string</td>
            <td>String (ASCII-8BIT)</td>
          </tr>
        
      </tbody>
    </table>
  </body>
</html>

