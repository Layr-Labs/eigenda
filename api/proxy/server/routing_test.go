package server

import (
	"fmt"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/Layr-Labs/eigenda/api/proxy/common/proxyerrors"
	"github.com/Layr-Labs/eigenda/api/proxy/metrics"
	"github.com/Layr-Labs/eigenda/api/proxy/test/mocks"
	"github.com/gorilla/mux"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.uber.org/mock/gomock"
)

// TestRouting tests that the routes were properly encoded.
// We should eventually replace this with autogenerated specmatic tests over an openapi spec.
func TestRouting(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	mockRouter := mocks.NewMockIManager(ctrl)

	m := metrics.NewMetrics(prometheus.NewRegistry())
	server := NewServer(testCfg, mockRouter, testLogger, m)
	r := mux.NewRouter()
	err := server.Start(r)
	require.NoError(t, err)

	tests := []struct {
		name         string
		url          string
		method       string
		body         []byte
		expectedCode int
		expectedBody string
	}{
		{
			name:   "Not Found - Must have a commitment key",
			url:    "/get/0x",
			method: http.MethodGet,
			body:   nil,
			// originally we returned 400 for these, but now we return 404 because
			// not having a commitment is not a valid route.
			expectedCode: http.StatusNotFound,
			expectedBody: "404 page not found\n",
		},
		{
			name: "Not Found - Op Mode InvalidCommitmentKey",
			url:  "/get/0x1",
			body: nil,
			// originally we returned 400 for these, but now we return 404 because
			// not having a commitment is not a valid route.
			expectedCode: http.StatusNotFound,
			expectedBody: "404 page not found\n",
		},
		{
			name: "Not Found - Op Mode InvalidCommitmentKey",
			url:  "/get/0x999",
			body: nil,
			// originally we returned 400 for these, but now we return 404 because
			// not having a commitment is not a valid route.
			expectedCode: http.StatusNotFound,
			expectedBody: "404 page not found\n",
		},
		{
			name:   "Not Found OP Keccak256 - TooShortCommitmentKey",
			url:    "/put/0x",
			method: http.MethodPut,
			body:   []byte("some data"),
			// originally we returned 400 for these, but now we return 404 because
			// not having a commitment is not a valid route.
			expectedCode: http.StatusNotFound,
			expectedBody: "404 page not found\n",
		},
		{
			name: "Not Found OP Keccak256 - TooShortCommitmentKey",
			url:  "/put/0x1",
			body: []byte("some data"),
			// originally we returned 400 for these, but now we return 404 because
			// not having a commitment is not a valid route.
			expectedCode: http.StatusNotFound,
			expectedBody: "404 page not found\n",
		},
		{
			name: "Not Found OP Keccak256 - InvalidCommitmentPrefixBytes",
			url:  fmt.Sprintf("/put/0x999%s", testCommitStr),
			body: []byte("some data"),
			// originally we returned 400 for these, but now we return 404 because
			// not having a commitment is not a valid route.
			expectedCode: http.StatusNotFound,
			expectedBody: "404 page not found\n",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Log(tt.name)
			req := httptest.NewRequest(tt.method, tt.url, nil)
			rec := httptest.NewRecorder()
			server.httpServer.Handler.ServeHTTP(rec, req)

			require.Equal(t, tt.expectedCode, rec.Code)
			require.Equal(t, tt.expectedBody, rec.Body.String())

		})
	}
}

func TestParseCommitmentInclusionL1BlockNumQueryParam(t *testing.T) {
	tests := []struct {
		queryParam     string
		expectedResult uint64
		expectedError  bool
	}{
		{
			queryParam:     "",
			expectedResult: 0,
			expectedError:  false,
		},
		{
			queryParam:     "l1_inclusion_block_number=",
			expectedResult: 0,
			expectedError:  false,
		},
		{
			queryParam:     "l1_inclusion_block_number=0",
			expectedResult: 0,
			expectedError:  false,
		},
		{
			queryParam:     "l1_inclusion_block_number=12345",
			expectedResult: 12345,
			expectedError:  false,
		},
		{
			queryParam:     "l1_inclusion_block_number=18446744073709551615", // max uint64
			expectedResult: 18446744073709551615,
			expectedError:  false,
		},
		{
			queryParam:     "l1_inclusion_block_number=abc123",
			expectedResult: 0,
			expectedError:  true,
		},
		{
			queryParam:     "l1_inclusion_block_number=-100",
			expectedResult: 0,
			expectedError:  true,
		},
		{
			queryParam:     "l1_inclusion_block_number=18446744073709551616", // max uint64 + 1
			expectedResult: 0,
			expectedError:  true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.queryParam, func(t *testing.T) {
			// Create test request with query parameters
			req := httptest.NewRequest(http.MethodGet, fmt.Sprintf("/test?%s", tt.queryParam), nil)
			result, err := parseCommitmentInclusionL1BlockNumQueryParam(req)

			// Check results
			if tt.expectedError {
				assert.Error(t, err)
				// Verify it's the right type of error
				assert.ErrorAs(t, err, &proxyerrors.L1InclusionBlockNumberParsingError{})
			} else {
				assert.NoError(t, err)
				assert.Equal(t, tt.expectedResult, result)
			}
		})
	}
}

func TestParseReturnEncodedPayloadQueryParam(t *testing.T) {
	tests := []struct {
		queryParam     string
		expectedResult bool
	}{
		{
			queryParam:     "return_encoded_payload",
			expectedResult: true,
		},
		{
			queryParam:     "return_encoded_payload=true",
			expectedResult: true,
		},
		{
			queryParam:     "return_encoded_payload=TRUE",
			expectedResult: true,
		},
		{
			queryParam:     "return_encoded_payload=1",
			expectedResult: true,
		},
		// first value takes precedence if multiple are provided
		{
			queryParam:     "return_encoded_payload=true&return_encoded_payload=false",
			expectedResult: true,
		},
		{
			queryParam:     "return_encoded_payload=false&return_encoded_payload=true",
			expectedResult: false,
		},
		{
			queryParam:     "",
			expectedResult: false,
		},
		{
			queryParam:     "return_encoded_payload=false",
			expectedResult: false, // Still true because presence is all that matters
		},
		{
			queryParam:     "return_encoded_payload=anything",
			expectedResult: false,
		},
		{
			queryParam:     "other_param=value",
			expectedResult: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.queryParam, func(t *testing.T) {
			// Create test request with query parameters
			req := httptest.NewRequest(http.MethodGet, fmt.Sprintf("/test?%s", tt.queryParam), nil)

			// Call the function being tested
			result := parseReturnEncodedPayloadQueryParam(req)

			// Check result
			assert.Equal(t, tt.expectedResult, result)
		})
	}
}
