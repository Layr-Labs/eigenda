package coretypes

import (
	"fmt"

	disperser "github.com/Layr-Labs/eigenda/api/grpc/disperser/v2"
	contractEigenDACertVerifierV2 "github.com/Layr-Labs/eigenda/contracts/bindings/EigenDACertVerifierV2"
	certTypesBinding "github.com/Layr-Labs/eigenda/contracts/bindings/IEigenDACertTypeBindings"
	coreV2 "github.com/Layr-Labs/eigenda/core/v2"
	"github.com/Layr-Labs/eigenda/encoding"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/rlp"
)

var (
	v3CertTypeEncodeArgs abi.Arguments
)

func init() {
	// load the ABI and parse the dummy interface methods used to encode the cert
	// NOTE: the only other way would be defining the certificate using go-ethereum's abi
	// low level types which would require much boiler plate
	certTypesBinding, err := certTypesBinding.ContractIEigenDACertTypeBindingsMetaData.GetAbi()
	if err != nil {
		panic(err)
	}

	v3CertTypeEncodeMethod, ok := certTypesBinding.Methods["dummyVerifyDACertV3"]
	if !ok {
		panic("dummyVerifyDACertV3 not found in IEigenDACertTypes ABI")
	}

	v3CertTypeEncodeArgs = v3CertTypeEncodeMethod.Inputs

}

// CertificateVersion denotes the version of the EigenDA certificate
// and is interpreted from querying the EigenDACertVerifier contract's
// CertVersion() view function
type CertificateVersion = uint64

const (
	// starting at two since we never formally defined a V1 cert in the core code
	VersionTwoCert   = 0x2
	VersionThreeCert = 0x3
)

// VerifyStatusCode reflects the return byte generated by a verification call to a generic cert verifier
type VerifyStatusCode uint8

const (
	// NULL_ERROR Unused status code. If this is returned, there is a bug in the code.
	StatusNullError VerifyStatusCode = iota
	// SUCCESS Verification succeeded
	StatusSuccess
	// INVALID_INCLUSION_PROOF Merkle inclusion proof is invalid
	StatusInvalidInclusionProof
	// SECURITY_ASSUMPTIONS_NOT_MET Security assumptions not met
	StatusSecurityAssumptionsNotMet
	// BLOB_QUORUMS_NOT_SUBSET Blob quorums not a subset of confirmed quorums
	StatusBlobQuorumsNotSubset
	// REQUIRED_QUORUMS_NOT_SUBSET Required quorums not a subset of blob quorums
	StatusRequiredQuorumsNotSubset
)

// String returns a human-readable representation of the StatusCode.
func (s VerifyStatusCode) String() string {
	switch s {
	case StatusNullError:
		return "Null Error: Unused status code. If this is returned, there is a bug in the code."
	case StatusSuccess:
		return "Success: Verification succeeded"
	case StatusInvalidInclusionProof:
		return "Invalid inclusion proof detected: Merkle inclusion proof for blob batch is invalid"
	case StatusSecurityAssumptionsNotMet:
		return "Security assumptions not met: BLS signer weight is less than the required threshold"
	case StatusBlobQuorumsNotSubset:
		return "Blob quorums are not a subset of the confirmed quorums"
	case StatusRequiredQuorumsNotSubset:
		return "Required quorums are not a subset of the blob quorums"
	default:
		return "Unknown status code"
	}
}

type EigenDACert interface {
	BlobVersion()coreV2.BlobVersion
	RelayKeys() []coreV2.RelayKey
	Version() CertificateVersion
	ReferenceBlockNumber() uint64
	QuorumNumbers() []byte

	ComputeBlobKey() (*coreV2.BlobKey, error)
	Commitments() (*encoding.BlobCommitments, error)
	Serialize() ([]byte, error)
}

var _ EigenDACert = &EigenDACertV2{}
var _ EigenDACert = &EigenDACertV3{}


// This struct represents the composition of a EigenDA V3 certificate, as it would exist in a rollup inbox.
type EigenDACertV3 certTypesBinding.EigenDACertTypesEigenDACertV3

// BuildEigenDACertV3 creates a new EigenDACertV3 from a BlobStatusReply, and NonSignerStakesAndSignature
func BuildEigenDACertV3(
	blobStatusReply *disperser.BlobStatusReply,
	nonSignerStakesAndSignature *certTypesBinding.EigenDATypesV1NonSignerStakesAndSignature,
) (*EigenDACertV3, error) {

	bindingInclusionInfo, err := InclusionInfoProtoToIEigenDATypesBinding(blobStatusReply.GetBlobInclusionInfo())
	if err != nil {
		return nil, fmt.Errorf("convert inclusion info to binding: %w", err)
	}

	signedBatch := blobStatusReply.GetSignedBatch()

	bindingBatchHeader, err := BatchHeaderProtoToIEigenDATypesBinding(signedBatch.GetHeader())
	if err != nil {
		return nil, fmt.Errorf("convert batch header to binding: %w", err)
	}

	quorumNumbers, err := QuorumNumbersUint32ToUint8(signedBatch.GetAttestation().GetQuorumNumbers())
	if err != nil {
		return nil, fmt.Errorf("convert quorum numbers to uint8: %w", err)
	}

	return &EigenDACertV3{
		BlobInclusionInfo:           *bindingInclusionInfo,
		BatchHeader:                 *bindingBatchHeader,
		NonSignerStakesAndSignature: *nonSignerStakesAndSignature,
		SignedQuorumNumbers:         quorumNumbers,
	}, nil
}

// RelayKeys returns the relay keys used for reading blob contents from disperser relays
func (c *EigenDACertV3) RelayKeys() []coreV2.RelayKey {
	return c.BlobInclusionInfo.BlobCertificate.RelayKeys
}

// QuorumNumbers returns the quorum numbers requested
func (c *EigenDACertV3) QuorumNumbers() []byte {
	return c.BlobInclusionInfo.BlobCertificate.BlobHeader.QuorumNumbers
}

// RBN returns the reference block number
func (c *EigenDACertV3) ReferenceBlockNumber() uint64 {
	return uint64(c.BatchHeader.ReferenceBlockNumber)
}

// BlobVersion returns the blob version of the blob header
func (c *EigenDACertV3) BlobVersion()coreV2.BlobVersion {
	return c.BlobInclusionInfo.BlobCertificate.BlobHeader.Version
}

// ComputeBlobKey computes the blob key used for looking up the blob against an EigenDA network retrieval
// entrypoint (e.g, a relay or a validator node)
func (c *EigenDACertV3) ComputeBlobKey() (*coreV2.BlobKey, error) {
	blobHeader := c.BlobInclusionInfo.BlobCertificate.BlobHeader
	blobCommitments, err := c.Commitments()
	if err != nil {
		return nil, fmt.Errorf("blob commitments from protobuf: %w", err)
	}

	blobKeyBytes, err :=coreV2.ComputeBlobKey(
		blobHeader.Version,
		*blobCommitments,
		blobHeader.QuorumNumbers,
		blobHeader.PaymentHeaderHash,
	)
	if err != nil {
		return nil, fmt.Errorf("compute blob key: %w", err)
	}
	blobKey, err :=coreV2.BytesToBlobKey(blobKeyBytes[:])
	if err != nil {
		return nil, fmt.Errorf("bytes to blob key: %w", err)
	}
	return &blobKey, nil
}

func (c *EigenDACertV3) Serialize() ([]byte, error) {
	return v3CertTypeEncodeArgs.Pack(c)
}

// Commitments returns the blob's cryptographic kzg commitments 
func (c *EigenDACertV3) Commitments() (*encoding.BlobCommitments, error) {
		// TODO: figure out how to remove this casting entirely
		commitments := contractEigenDACertVerifierV2.EigenDATypesV2BlobCommitment{
			Commitment: contractEigenDACertVerifierV2.BN254G1Point{
				X: c.BlobInclusionInfo.BlobCertificate.BlobHeader.Commitment.Commitment.X,
				Y: c.BlobInclusionInfo.BlobCertificate.BlobHeader.Commitment.Commitment.Y,
			},
			LengthCommitment: contractEigenDACertVerifierV2.BN254G2Point{
				X: c.BlobInclusionInfo.BlobCertificate.BlobHeader.Commitment.LengthCommitment.X,
				Y: c.BlobInclusionInfo.BlobCertificate.BlobHeader.Commitment.LengthCommitment.Y,
			},
			LengthProof: contractEigenDACertVerifierV2.BN254G2Point{
				X: c.BlobInclusionInfo.BlobCertificate.BlobHeader.Commitment.LengthProof.X,
				Y: c.BlobInclusionInfo.BlobCertificate.BlobHeader.Commitment.LengthProof.Y,
			},
			Length: c.BlobInclusionInfo.BlobCertificate.BlobHeader.Commitment.Length,
		}
	
		blobCommitments, err := BlobCommitmentsBindingToInternal(&commitments)
		if err != nil {
			return nil, fmt.Errorf("blob commitments from protobuf: %w", err)
		}

		return blobCommitments, nil
}

// Version returns the version of the EigenDA certificate
func (c *EigenDACertV3) Version() CertificateVersion {
	return VersionThreeCert
}

// This struct represents the composition of an EigenDA V2 certificate
// NOTE: This type is hardforked from the V3 type and will no longer
//       be supported for dispersals after the CertV3 hardfork
type EigenDACertV2 struct {
	BlobInclusionInfo           contractEigenDACertVerifierV2.EigenDATypesV2BlobInclusionInfo
	BatchHeader                 contractEigenDACertVerifierV2.EigenDATypesV2BatchHeaderV2
	NonSignerStakesAndSignature contractEigenDACertVerifierV2.EigenDATypesV1NonSignerStakesAndSignature
	SignedQuorumNumbers         []byte
}

// BuildEigenDAV2Cert creates a new EigenDACertV2 from a BlobStatusReply, and NonSignerStakesAndSignature
func BuildEigenDAV2Cert(
	blobStatusReply *disperser.BlobStatusReply,
	nonSignerStakesAndSignature *contractEigenDACertVerifierV2.EigenDATypesV1NonSignerStakesAndSignature,
) (*EigenDACertV2, error) {

	bindingInclusionInfo, err := InclusionInfoProtoToV2CertVerifierBinding(blobStatusReply.GetBlobInclusionInfo())
	if err != nil {
		return nil, fmt.Errorf("convert inclusion info to binding: %w", err)
	}

	signedBatch := blobStatusReply.GetSignedBatch()

	bindingBatchHeader, err := BatchHeaderProtoToV2CertVerifierBinding(signedBatch.GetHeader())
	if err != nil {
		return nil, fmt.Errorf("convert batch header to binding: %w", err)
	}

	quorumNumbers, err := QuorumNumbersUint32ToUint8(signedBatch.GetAttestation().GetQuorumNumbers())
	if err != nil {
		return nil, fmt.Errorf("convert quorum numbers to uint8: %w", err)
	}

	return &EigenDACertV2{
		BlobInclusionInfo:           *bindingInclusionInfo,
		BatchHeader:                 *bindingBatchHeader,
		NonSignerStakesAndSignature: *nonSignerStakesAndSignature,
		SignedQuorumNumbers:         quorumNumbers,
	}, nil
}
// RelayKeys returns the relay keys used for reading blob contents from disperser relays
func (c *EigenDACertV2) RelayKeys() []coreV2.RelayKey {
	return c.BlobInclusionInfo.BlobCertificate.RelayKeys
}

// Commitments returns the blob's cryptographic kzg commitments 
func (c *EigenDACertV2) Commitments() (*encoding.BlobCommitments, error) {
	return BlobCommitmentsBindingToInternal(
		&c.BlobInclusionInfo.BlobCertificate.BlobHeader.Commitment)
}

// RBN returns the reference block number
func (c *EigenDACertV2) ReferenceBlockNumber() uint64 {
	return uint64(c.BatchHeader.ReferenceBlockNumber)
}

// BlobVersion returns the blob version of the blob header
func (c *EigenDACertV2) BlobVersion()coreV2.BlobVersion {
	return c.BlobInclusionInfo.BlobCertificate.BlobHeader.Version
}
// QuorumNumbers returns the quorum numbers requested
func (c *EigenDACertV2) QuorumNumbers() []byte {
	return c.BlobInclusionInfo.BlobCertificate.BlobHeader.QuorumNumbers
}

// Serialize serializes the EigenDACertV2 to bytes
func (c *EigenDACertV2) Serialize() ([]byte, error) {
	b, err := rlp.EncodeToBytes(c)
	if err != nil {
		return nil, fmt.Errorf("rlp encode v2 cert: %w", err)
	}

	return b, nil
}


// ComputeBlobKey computes the BlobKey of the blob that belongs to the EigenDACertV2
func (c *EigenDACertV2) ComputeBlobKey() (*coreV2.BlobKey, error) {
	blobHeader := c.BlobInclusionInfo.BlobCertificate.BlobHeader

	blobCommitments, err := BlobCommitmentsBindingToInternal(&blobHeader.Commitment)
	if err != nil {
		return nil, fmt.Errorf("blob commitments from protobuf: %w", err)
	}

	blobKeyBytes, err :=coreV2.ComputeBlobKey(
		blobHeader.Version,
		*blobCommitments,
		blobHeader.QuorumNumbers,
		blobHeader.PaymentHeaderHash,
	)

	if err != nil {
		return nil, fmt.Errorf("compute blob key: %w", err)
	}

	blobKey, err :=coreV2.BytesToBlobKey(blobKeyBytes[:])
	if err != nil {
		return nil, fmt.Errorf("bytes to blob key: %w", err)
	}

	return &blobKey, nil
}

// Version returns the version of the EigenDA certificate
func (c *EigenDACertV2) Version() CertificateVersion {
	return VersionTwoCert
}