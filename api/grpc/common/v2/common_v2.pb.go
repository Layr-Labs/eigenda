// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.1
// 	protoc        v4.23.4
// source: common/v2/common_v2.proto

package v2

import (
	common "github.com/Layr-Labs/eigenda/api/grpc/common"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// BlobHeader contains the information describing a blob and the way it is to be dispersed.
type BlobHeader struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The BlobParams version to use when encoding the blob into chunks to be dispersed to operators.
	//
	// BlobParams versions are pushed onchain to the EigenDAThresholdRegistry by EigenDA governance in an append only fashion
	// and store the maximum number of operators, number of chunks, and coding rate for a blob.
	//
	// A user can choose any of the onchain defined VersionedBlobParams, and must make sure to choose SecurityThresholds in its CertVerifier contract
	// that along with the chosen VersionedBlobParams satisfy the checkSecurityParams function: https://github.com/Layr-Labs/eigenda/blob/3e670ff3dbd3a0a3f63b51e40544f528ac923b78/contracts/src/periphery/cert/libraries/EigenDACertVerificationLib.sol#L188
	// This function is called internally by the CertVerifier's checkDACert function.
	//
	// If a version that is not available on the ThresholdRegistry is chosen, the disperser will return an error.
	//
	// EigenDA maintained:
	//
	//	VersionedBlobParams definition: https://github.com/Layr-Labs/eigenda/blob/3e670ff3dbd3a0a3f63b51e40544f528ac923b78/contracts/src/core/libraries/v1/EigenDATypesV1.sol#L7
	//	IEigenDAThresholdRegistry (stores the BlobParams): https://github.com/Layr-Labs/eigenda/blob/3e670ff3dbd3a0a3f63b51e40544f528ac923b78/contracts/src/core/interfaces/IEigenDAThresholdRegistry.sol
	//	EigenDAServiceManager address (implements IEigenDAThresholdRegistry): https://docs.eigenda.xyz/networks/mainnet#contract-addresses
	//
	// Rollup maintained:
	//
	//	SecurityThresholds interface: https://github.com/Layr-Labs/eigenda/blob/3e670ff3dbd3a0a3f63b51e40544f528ac923b78/contracts/src/periphery/cert/interfaces/IEigenDACertVerifier.sol#L23
	//	checkDACert interface: https://github.com/Layr-Labs/eigenda/blob/3e670ff3dbd3a0a3f63b51e40544f528ac923b78/contracts/src/periphery/cert/interfaces/IEigenDACertVerifierBase.sol#L8
	Version uint32 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	// quorum_numbers is the list of quorum numbers that the blob shall be dispersed to.
	// Each quorum will store the data independently, meaning that additional quorum numbers increase redundancy, making the blob more likely to be retrievable.
	// Each quorum requires separate payment.
	//
	// On-demand bandwidth dispersals do not currently support custom quorums and hence are limited to dispersing to one or two of the following quorums only:
	// - 0: ETH
	// - 1: EIGEN
	//
	// Reserved-bandwidth dispersal do support custom quorums, as long as they are reserved onchain ahead of time. The quorum_numbers specified here must be a subset of the ones allowed by the on-chain reservation.
	// Users can check their reserved quorum numbers on the IPaymentVault's reservation struct: https://github.com/Layr-Labs/eigenda/blob/1430d56258b4e814b388e497320fd76354bfb478/contracts/src/interfaces/IPaymentVault.sol#L10
	QuorumNumbers []uint32 `protobuf:"varint,2,rep,packed,name=quorum_numbers,json=quorumNumbers,proto3" json:"quorum_numbers,omitempty"`
	// commitment is the KZG commitment to the blob.
	// This commitment can either be constructed locally, or obtained by using the disperser's GetBlobCommitment RPC (see disperser_v2.proto).
	Commitment *common.BlobCommitment `protobuf:"bytes,3,opt,name=commitment,proto3" json:"commitment,omitempty"`
	// payment_header contains payment information for the blob
	PaymentHeader *PaymentHeader `protobuf:"bytes,4,opt,name=payment_header,json=paymentHeader,proto3" json:"payment_header,omitempty"`
}

func (x *BlobHeader) Reset() {
	*x = BlobHeader{}
	if protoimpl.UnsafeEnabled {
		mi := &file_common_v2_common_v2_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BlobHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BlobHeader) ProtoMessage() {}

func (x *BlobHeader) ProtoReflect() protoreflect.Message {
	mi := &file_common_v2_common_v2_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BlobHeader.ProtoReflect.Descriptor instead.
func (*BlobHeader) Descriptor() ([]byte, []int) {
	return file_common_v2_common_v2_proto_rawDescGZIP(), []int{0}
}

func (x *BlobHeader) GetVersion() uint32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *BlobHeader) GetQuorumNumbers() []uint32 {
	if x != nil {
		return x.QuorumNumbers
	}
	return nil
}

func (x *BlobHeader) GetCommitment() *common.BlobCommitment {
	if x != nil {
		return x.Commitment
	}
	return nil
}

func (x *BlobHeader) GetPaymentHeader() *PaymentHeader {
	if x != nil {
		return x.PaymentHeader
	}
	return nil
}

// BlobCertificate contains a full description of a blob and how it is dispersed. Part of the certificate
// is provided by the blob submitter (i.e. the blob header), and part is provided by the disperser (i.e. the relays).
// Validator nodes eventually sign the blob certificate once they are in custody of the required chunks
// (note that the signature is indirect; validators sign the hash of a Batch, which contains the blob certificate).
type BlobCertificate struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// blob_header contains data about the blob.
	BlobHeader *BlobHeader `protobuf:"bytes,1,opt,name=blob_header,json=blobHeader,proto3" json:"blob_header,omitempty"`
	// signature is an ECDSA signature signed by the blob request signer's account ID over the BlobHeader's blobKey,
	// which is a keccak hash of the serialized BlobHeader, and used to verify against blob dispersal request's account ID
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	// relay_keys is the list of relay keys that are in custody of the blob.
	// The relays custodying the data are chosen by the Disperser to which the DisperseBlob request was submitted.
	// It needs to contain at least 1 relay number.
	// To retrieve a blob from the relay, one can find that relay's URL in the EigenDARelayRegistry contract:
	// https://github.com/Layr-Labs/eigenda/blob/master/contracts/src/core/EigenDARelayRegistry.sol
	RelayKeys []uint32 `protobuf:"varint,3,rep,packed,name=relay_keys,json=relayKeys,proto3" json:"relay_keys,omitempty"`
}

func (x *BlobCertificate) Reset() {
	*x = BlobCertificate{}
	if protoimpl.UnsafeEnabled {
		mi := &file_common_v2_common_v2_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BlobCertificate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BlobCertificate) ProtoMessage() {}

func (x *BlobCertificate) ProtoReflect() protoreflect.Message {
	mi := &file_common_v2_common_v2_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BlobCertificate.ProtoReflect.Descriptor instead.
func (*BlobCertificate) Descriptor() ([]byte, []int) {
	return file_common_v2_common_v2_proto_rawDescGZIP(), []int{1}
}

func (x *BlobCertificate) GetBlobHeader() *BlobHeader {
	if x != nil {
		return x.BlobHeader
	}
	return nil
}

func (x *BlobCertificate) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *BlobCertificate) GetRelayKeys() []uint32 {
	if x != nil {
		return x.RelayKeys
	}
	return nil
}

// BatchHeader is the header of a batch of blobs
type BatchHeader struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// batch_root is the root of the merkle tree of the hashes of blob certificates in the batch
	BatchRoot []byte `protobuf:"bytes,1,opt,name=batch_root,json=batchRoot,proto3" json:"batch_root,omitempty"`
	// reference_block_number is the block number that the state of the batch is based on for attestation
	ReferenceBlockNumber uint64 `protobuf:"varint,2,opt,name=reference_block_number,json=referenceBlockNumber,proto3" json:"reference_block_number,omitempty"`
}

func (x *BatchHeader) Reset() {
	*x = BatchHeader{}
	if protoimpl.UnsafeEnabled {
		mi := &file_common_v2_common_v2_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BatchHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchHeader) ProtoMessage() {}

func (x *BatchHeader) ProtoReflect() protoreflect.Message {
	mi := &file_common_v2_common_v2_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchHeader.ProtoReflect.Descriptor instead.
func (*BatchHeader) Descriptor() ([]byte, []int) {
	return file_common_v2_common_v2_proto_rawDescGZIP(), []int{2}
}

func (x *BatchHeader) GetBatchRoot() []byte {
	if x != nil {
		return x.BatchRoot
	}
	return nil
}

func (x *BatchHeader) GetReferenceBlockNumber() uint64 {
	if x != nil {
		return x.ReferenceBlockNumber
	}
	return 0
}

// Batch is a batch of blob certificates
type Batch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// header contains metadata about the batch
	Header *BatchHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// blob_certificates is the list of blob certificates in the batch
	BlobCertificates []*BlobCertificate `protobuf:"bytes,2,rep,name=blob_certificates,json=blobCertificates,proto3" json:"blob_certificates,omitempty"`
}

func (x *Batch) Reset() {
	*x = Batch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_common_v2_common_v2_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Batch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Batch) ProtoMessage() {}

func (x *Batch) ProtoReflect() protoreflect.Message {
	mi := &file_common_v2_common_v2_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Batch.ProtoReflect.Descriptor instead.
func (*Batch) Descriptor() ([]byte, []int) {
	return file_common_v2_common_v2_proto_rawDescGZIP(), []int{3}
}

func (x *Batch) GetHeader() *BatchHeader {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *Batch) GetBlobCertificates() []*BlobCertificate {
	if x != nil {
		return x.BlobCertificates
	}
	return nil
}

// PaymentHeader contains payment information for a blob, which is crucial for validating and processing dispersal requests.
// The PaymentHeader is designed to support two distinct payment methods within the EigenDA protocol:
//
//  1. Reservation-based payment system:
//     This system allows users to reserve bandwidth in advance for a specified time period. It's designed for
//     users who need predictable throughput with a fixed ratelimit bin in required or custom quorums.
//     Under this method, the user pre-arranges a reservation with specific parameters on the desired quorums:
//     - symbolsPerSecond: The rate at which they can disperse data
//     - startTimestamp and endTimestamp: The timeframe during which the reservation is active
//
//  2. On-demand payment system:
//     This is a pay-as-you-go model where users deposit funds into the PaymentVault contract and
//     payments are deducted as they make dispersal requests. This system is more flexible but has
//     more restrictions on which quorums can be used (currently limited to quorums 0 and 1).
//
// The disperser client always attempts to use a reservation-based payment first if one exists for the account.
// If no valid reservation exists or if the reservation doesn't have enough remaining bandwidth,
// the client will fall back to on-demand payment, provided the user has deposited sufficient funds
// in the PaymentVault contract.
//
// The distinction between these two payment methods is made by examining:
// - For reservation-based: The timestamp must be within an active reservation period, and cumulative_payment is zero or empty
// - For on-demand: The cumulative_payment field contains a non-zero value representing the total payment for all dispersals
//
// Every dispersal request is metered based on the size of the data being dispersed, rounded up to the
// nearest multiple of the minNumSymbols parameter defined in the PaymentVault contract. The size is calculated as:
// symbols_charged = ceiling(blob_size / minNumSymbols) * minNumSymbols
// On-demand payments take a step further by calculating the specific cost
// cost = symbols_charged * price_per_symbol
//
// Security and Authentication:
// The payment header is protected by a cryptographic signature that covers the entire BlobHeader.
// This signature is verified during request processing to ensure that:
// 1. The request is genuinely from the holder of the private key corresponding to account_id
// 2. The payment information hasn't been tampered with
// 3. The same request isn't being resubmitted (replay protection)
//
// This signature verification happens in core/auth/v2/authenticator.go where:
// - The BlobKey (a hash of the serialized BlobHeader) is computed
// - The signature is verified against this key
// - The recovered public key is checked against the account_id in the payment header
//
// Once a payment has been processed and the signature verified, the disperser server will not
// roll back the payment or usage records, even if subsequent processing fails. This design choice
// prevents double-spending and ensures payment integrity.
type PaymentHeader struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The account ID of the disperser client, represented as an Ethereum wallet address in hex format
	// (e.g., "0x1234...abcd"). This field is critical for both payment methods as it:
	//
	// 1. Identifies whose reservation to check for reservation-based payments
	// 2. Identifies whose on-chain deposit balance to check for on-demand payments
	// 3. Provides the address against which the BlobHeader signature is verified
	//
	// The account_id has special significance in the authentication flow:
	// - When a client signs a BlobHeader, they use their private key
	// - The disperser server recovers the public key from this signature
	// - The recovered public key is converted to an Ethereum address
	// - This derived address must exactly match the account_id in this field
	//
	// This verification process (implemented in core/auth/v2/authenticator.go's AuthenticateBlobRequest method)
	// ensures that only the legitimate owner of the account can submit dispersal requests charged to that account.
	// It prevents unauthorized payments or impersonation attacks where someone might try to use another
	// user's reservation or on-chain balance.
	//
	// The account_id is typically set by the client's Accountant when constructing the PaymentMetadata
	// (see api/clients/v2/accountant.go - AccountBlob method).
	AccountId string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
	// The timestamp represents the UNIX timestamp in nanoseconds at the time the dispersal
	// request is created. This high-precision timestamp serves multiple critical functions in the protocol:
	//
	// For reservation-based payments:
	//  1. Reservation Period Determination:
	//     The timestamp is used to calculate which reservation period the request belongs to using the formula:
	//     reservation_period = floor(timestamp_ns / (reservationPeriodInterval_s * 1e9)) * reservationPeriodInterval_s
	//     where reservationPeriodInterval_s is in seconds, and the result is in seconds.
	//
	//  2. Reservation Validity Check:
	//     The timestamp must fall within an active reservation window:
	//     - It must be >= the reservation's startTimestamp (in seconds)
	//     - It must be < the reservation's endTimestamp (in seconds)
	//
	//  3. Period Window Check:
	//     The server validates that the request's reservation period is either:
	//     - The current period (based on server time)
	//     - The immediately previous period
	//     This prevents requests with future timestamps or very old timestamps.
	//
	//  4. Rate Limiting:
	//     The server uses the timestamp to allocate the request to the appropriate rate-limiting bucket.
	//     Each reservation period has a fixed bandwidth limit (symbolsPerSecond * reservationPeriodInterval).
	//
	// For on-demand payments:
	//  1. Replay Protection:
	//     The timestamp helps ensure each request is unique and prevent replay attacks.
	//
	//  2. Global Ratelimiting (TO BE IMPLEMENTED):
	//     Treating all on-demand requests as an user-agnostic more frequent reservation, timestamp is checked
	//     against the OnDemandSymbolsPerSecond and OnDemandPeriodInterval.
	//
	// The timestamp is typically acquired by calling time.Now().UnixNano() in Go and accounted for NTP offsets
	// by periodically syncing with a configuratble NTP server endpoint. The client's Accountant component
	// (api/clients/v2/accountant.go) expects the caller to provide this timestamp, which it then
	// uses to determine the correct reservation period and check bandwidth availability.
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// The cumulative_payment field is a serialized uint256 big integer representing the total amount of tokens
	// paid by the requesting account across all their dispersal requests, including the current one. The unit is in wei.
	// This field is exclusively used for on-demand payments and should be zero or empty for reservation-based payments.
	// If this field is zero or empty, disperser server's meterer will treat this request as reservation-based.
	// For the current implementation, the choice of quorum doesn't affect the payment calculations. A client may
	// choose to use any or all of the required quorums.
	//
	// Detailed Payment Mechanics:
	//  1. Cumulative Design:
	//     Rather than sending incremental payment amounts, the protocol uses a cumulative approach where
	//     each request states the total amount paid by the account so far. This design:
	//     - Prevents double-spending even with concurrent requests
	//     - Simplifies verification logic
	//     - Requests are enforced by a strictly increasing order
	//
	//  2. Calculation Formula:
	//     For a new dispersal request, the cumulative_payment is calculated as:
	//     new_cumulative = previous_cumulative + (symbols_charged * price_per_symbol)
	//
	//     Where:
	//     - previous_cumulative: The highest cumulative payment value from previous dispersals
	//     - symbols_charged: The blob size rounded up to the nearest multiple of minNumSymbols
	//     - price_per_symbol: The cost per symbol set in the PaymentVault contract
	//
	//  3. Validation Process:
	//     When the disperser receives a request with a cumulative_payment, it performs multiple validations:
	//     - Checks that the on-chain deposit balance in the PaymentVault is sufficient to cover this payment
	//     - Verifies the cumulative_payment is greater than the highest previous payment from this account
	//     - Verifies the increase from the previous cumulative payment is appropriate for the blob size
	//     - If other requests from the same account are currently processing, ensures this new cumulative
	//     value is consistent with those (preventing double-spending)
	//
	//  4. On-chain Implementation:
	//     The PaymentVault contract maintains:
	//     - A deposit balance for each account
	//     - Global parameters including minNumSymbols, GlobalSymbolsPerSecond and pricePerSymbol
	//
	// Due to the use of cumulative payments, if a client loses track of their current cumulative payment value,
	// they can query the disperser server for their current payment state using the GetPaymentState RPC.
	CumulativePayment []byte `protobuf:"bytes,3,opt,name=cumulative_payment,json=cumulativePayment,proto3" json:"cumulative_payment,omitempty"`
}

func (x *PaymentHeader) Reset() {
	*x = PaymentHeader{}
	if protoimpl.UnsafeEnabled {
		mi := &file_common_v2_common_v2_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PaymentHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PaymentHeader) ProtoMessage() {}

func (x *PaymentHeader) ProtoReflect() protoreflect.Message {
	mi := &file_common_v2_common_v2_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PaymentHeader.ProtoReflect.Descriptor instead.
func (*PaymentHeader) Descriptor() ([]byte, []int) {
	return file_common_v2_common_v2_proto_rawDescGZIP(), []int{4}
}

func (x *PaymentHeader) GetAccountId() string {
	if x != nil {
		return x.AccountId
	}
	return ""
}

func (x *PaymentHeader) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *PaymentHeader) GetCumulativePayment() []byte {
	if x != nil {
		return x.CumulativePayment
	}
	return nil
}

var File_common_v2_common_v2_proto protoreflect.FileDescriptor

var file_common_v2_common_v2_proto_rawDesc = []byte{
	0x0a, 0x19, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2f, 0x76, 0x32, 0x2f, 0x63, 0x6f, 0x6d, 0x6d,
	0x6f, 0x6e, 0x5f, 0x76, 0x32, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x09, 0x63, 0x6f, 0x6d,
	0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x32, 0x1a, 0x13, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2f, 0x63,
	0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xc6, 0x01, 0x0a, 0x0a,
	0x42, 0x6c, 0x6f, 0x62, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x12, 0x18, 0x0a, 0x07, 0x76, 0x65,
	0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x07, 0x76, 0x65, 0x72,
	0x73, 0x69, 0x6f, 0x6e, 0x12, 0x25, 0x0a, 0x0e, 0x71, 0x75, 0x6f, 0x72, 0x75, 0x6d, 0x5f, 0x6e,
	0x75, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0d, 0x52, 0x0d, 0x71, 0x75,
	0x6f, 0x72, 0x75, 0x6d, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x12, 0x36, 0x0a, 0x0a, 0x63,
	0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x16, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x42, 0x6c, 0x6f, 0x62, 0x43, 0x6f, 0x6d,
	0x6d, 0x69, 0x74, 0x6d, 0x65, 0x6e, 0x74, 0x52, 0x0a, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x6d,
	0x65, 0x6e, 0x74, 0x12, 0x3f, 0x0a, 0x0e, 0x70, 0x61, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x68,
	0x65, 0x61, 0x64, 0x65, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x32, 0x2e, 0x50, 0x61, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x48,
	0x65, 0x61, 0x64, 0x65, 0x72, 0x52, 0x0d, 0x70, 0x61, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x48, 0x65,
	0x61, 0x64, 0x65, 0x72, 0x22, 0x86, 0x01, 0x0a, 0x0f, 0x42, 0x6c, 0x6f, 0x62, 0x43, 0x65, 0x72,
	0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x12, 0x36, 0x0a, 0x0b, 0x62, 0x6c, 0x6f, 0x62,
	0x5f, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e,
	0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x32, 0x2e, 0x42, 0x6c, 0x6f, 0x62, 0x48, 0x65,
	0x61, 0x64, 0x65, 0x72, 0x52, 0x0a, 0x62, 0x6c, 0x6f, 0x62, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72,
	0x12, 0x1c, 0x0a, 0x09, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0c, 0x52, 0x09, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x12, 0x1d,
	0x0a, 0x0a, 0x72, 0x65, 0x6c, 0x61, 0x79, 0x5f, 0x6b, 0x65, 0x79, 0x73, 0x18, 0x03, 0x20, 0x03,
	0x28, 0x0d, 0x52, 0x09, 0x72, 0x65, 0x6c, 0x61, 0x79, 0x4b, 0x65, 0x79, 0x73, 0x22, 0x62, 0x0a,
	0x0b, 0x42, 0x61, 0x74, 0x63, 0x68, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x12, 0x1d, 0x0a, 0x0a,
	0x62, 0x61, 0x74, 0x63, 0x68, 0x5f, 0x72, 0x6f, 0x6f, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c,
	0x52, 0x09, 0x62, 0x61, 0x74, 0x63, 0x68, 0x52, 0x6f, 0x6f, 0x74, 0x12, 0x34, 0x0a, 0x16, 0x72,
	0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x5f, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x6e,
	0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x14, 0x72, 0x65, 0x66,
	0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x4e, 0x75, 0x6d, 0x62, 0x65,
	0x72, 0x22, 0x80, 0x01, 0x0a, 0x05, 0x42, 0x61, 0x74, 0x63, 0x68, 0x12, 0x2e, 0x0a, 0x06, 0x68,
	0x65, 0x61, 0x64, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x32, 0x2e, 0x42, 0x61, 0x74, 0x63, 0x68, 0x48, 0x65, 0x61,
	0x64, 0x65, 0x72, 0x52, 0x06, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x12, 0x47, 0x0a, 0x11, 0x62,
	0x6c, 0x6f, 0x62, 0x5f, 0x63, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x73,
	0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e,
	0x76, 0x32, 0x2e, 0x42, 0x6c, 0x6f, 0x62, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61,
	0x74, 0x65, 0x52, 0x10, 0x62, 0x6c, 0x6f, 0x62, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63,
	0x61, 0x74, 0x65, 0x73, 0x22, 0x7b, 0x0a, 0x0d, 0x50, 0x61, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x48,
	0x65, 0x61, 0x64, 0x65, 0x72, 0x12, 0x1d, 0x0a, 0x0a, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74,
	0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x61, 0x63, 0x63, 0x6f, 0x75,
	0x6e, 0x74, 0x49, 0x64, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
	0x70, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61,
	0x6d, 0x70, 0x12, 0x2d, 0x0a, 0x12, 0x63, 0x75, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65,
	0x5f, 0x70, 0x61, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x11,
	0x63, 0x75, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65, 0x50, 0x61, 0x79, 0x6d, 0x65, 0x6e,
	0x74, 0x42, 0x31, 0x5a, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f,
	0x4c, 0x61, 0x79, 0x72, 0x2d, 0x4c, 0x61, 0x62, 0x73, 0x2f, 0x65, 0x69, 0x67, 0x65, 0x6e, 0x64,
	0x61, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x67, 0x72, 0x70, 0x63, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
	0x6e, 0x2f, 0x76, 0x32, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_common_v2_common_v2_proto_rawDescOnce sync.Once
	file_common_v2_common_v2_proto_rawDescData = file_common_v2_common_v2_proto_rawDesc
)

func file_common_v2_common_v2_proto_rawDescGZIP() []byte {
	file_common_v2_common_v2_proto_rawDescOnce.Do(func() {
		file_common_v2_common_v2_proto_rawDescData = protoimpl.X.CompressGZIP(file_common_v2_common_v2_proto_rawDescData)
	})
	return file_common_v2_common_v2_proto_rawDescData
}

var file_common_v2_common_v2_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_common_v2_common_v2_proto_goTypes = []interface{}{
	(*BlobHeader)(nil),            // 0: common.v2.BlobHeader
	(*BlobCertificate)(nil),       // 1: common.v2.BlobCertificate
	(*BatchHeader)(nil),           // 2: common.v2.BatchHeader
	(*Batch)(nil),                 // 3: common.v2.Batch
	(*PaymentHeader)(nil),         // 4: common.v2.PaymentHeader
	(*common.BlobCommitment)(nil), // 5: common.BlobCommitment
}
var file_common_v2_common_v2_proto_depIdxs = []int32{
	5, // 0: common.v2.BlobHeader.commitment:type_name -> common.BlobCommitment
	4, // 1: common.v2.BlobHeader.payment_header:type_name -> common.v2.PaymentHeader
	0, // 2: common.v2.BlobCertificate.blob_header:type_name -> common.v2.BlobHeader
	2, // 3: common.v2.Batch.header:type_name -> common.v2.BatchHeader
	1, // 4: common.v2.Batch.blob_certificates:type_name -> common.v2.BlobCertificate
	5, // [5:5] is the sub-list for method output_type
	5, // [5:5] is the sub-list for method input_type
	5, // [5:5] is the sub-list for extension type_name
	5, // [5:5] is the sub-list for extension extendee
	0, // [0:5] is the sub-list for field type_name
}

func init() { file_common_v2_common_v2_proto_init() }
func file_common_v2_common_v2_proto_init() {
	if File_common_v2_common_v2_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_common_v2_common_v2_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BlobHeader); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_common_v2_common_v2_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BlobCertificate); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_common_v2_common_v2_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BatchHeader); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_common_v2_common_v2_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Batch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_common_v2_common_v2_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PaymentHeader); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_common_v2_common_v2_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   5,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_common_v2_common_v2_proto_goTypes,
		DependencyIndexes: file_common_v2_common_v2_proto_depIdxs,
		MessageInfos:      file_common_v2_common_v2_proto_msgTypes,
	}.Build()
	File_common_v2_common_v2_proto = out.File
	file_common_v2_common_v2_proto_rawDesc = nil
	file_common_v2_common_v2_proto_goTypes = nil
	file_common_v2_common_v2_proto_depIdxs = nil
}
