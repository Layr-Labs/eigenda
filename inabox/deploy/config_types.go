package deploy

import (
	"log"
	"os"
	"path/filepath"

	gethcommon "github.com/ethereum/go-ethereum/common"
	"gopkg.in/yaml.v3"
)

type Staker struct {
	Address    string `json:"address"`
	PrivateKey string `json:"private"`
	Stake      string `json:"stake"`
}

type ContractDeployer struct {
	Name            string `yaml:"name"`
	RPC             string `yaml:"rpc"`
	VerifierURL     string `yaml:"verifierUrl"`
	VerifyContracts bool   `yaml:"verifyContracts"`
	Slow            bool   `yaml:"slow"`
	DeploySubgraphs bool   `yaml:"deploySubgraphs"`
	// PrivateKey string `yaml:"private_key"`
}

type TelemetryConfig struct {
	IsNeeded   bool     `yaml:"isNeeded"`
	ConfigPath string   `yaml:"configPath"`
	DockerSd   []string `yaml:"dockerSd"`
}

// EigenDAContract is the structured output generated by running
// forge script/Deployer.s.sol:SetupEigenDA
type EigenDAContract struct {
	Deployer               string `yaml:"deployer"`
	EigenDADirectory       string `json:"eigenDADirectory"`
	ServiceManager         string `json:"eigenDAServiceManager"`
	OperatorStateRetriever string `json:"operatorStateRetriever"`
	BlsApkRegistry         string `json:"blsApkRegistry"`
	RegistryCoordinator    string `json:"registryCoordinator"`
	CertVerifierLegacyV2   string `json:"eigenDALegacyCertVerifierV2"`
	CertVerifierLegacyV3   string `json:"eigenDALegacyCertVerifierV3"`
	CertVerifier           string `json:"eigenDACertVerifier"`
	CertVerifierRouter     string `json:"eigenDACertVerifierRouter"`
}

type Stakes struct {
	Total        float32   `yaml:"total"`
	Distribution []float32 `yaml:"distribution"`
}

type ServicesSpec struct {
	Counts struct {
		NumOpr              int `yaml:"operators"`
		NumMaxOperatorCount int `yaml:"maxOperatorCount"`
		NumRelays           int `yaml:"relays"`
	} `yaml:"counts"`
	Stakes    []Stakes  `yaml:"stakes"`
	BasePort  int       `yaml:"basePort"`
	Variables Variables `yaml:"variables"`
}

type Variables map[string]map[string]string

type KeyInfo struct {
	// The private key (e.g. ECDSA or BLS) in string.
	PrivateKey string `yaml:"privateKey"`
	// The password used to encrypt the private key.
	Password string `yaml:"password"`
	// The file path to the encrypted private key.
	KeyFile string `yaml:"keyFile"`
}

type BlobVersionParam struct {
	CodingRate      uint32 `yaml:"codingRate"`
	MaxNumOperators uint32 `yaml:"maxNumOperators"`
	NumChunks       uint32 `yaml:"numChunks"`
}

type PkConfig struct {
	EcdsaMap map[string]KeyInfo `yaml:"ecdsaMap"`
	BlsMap   map[string]KeyInfo `yaml:"blsMap"`
}

type Environment struct {
	Name string `yaml:"name"`
	Type string `yaml:"type"`
}

func (e Environment) IsLocal() bool {
	return e.Type == "local"
}

// Config is used by devnet inabox, whereas inabox when spun up for tests uses InfrastructureConfig instead.
// TODO: We should eventually find a way to consolidate them.
type Config struct {
	rootPath string

	Path     string
	TestName string

	Environment Environment `yaml:"environment"`

	Deployers []*ContractDeployer `yaml:"deployers"`

	EigenDA               EigenDAContract     `yaml:"eigenda"`
	BlobVersionParams     []*BlobVersionParam `yaml:"blobVersions"`
	EigenDAV2CertVerifier string              `yaml:"v2CertVerifier" json:"v2CertVerifier"`

	Pks *PkConfig `yaml:"privateKeys"`

	Services ServicesSpec `yaml:"services"`

	Telemetry TelemetryConfig `yaml:"telemetry"`

	Churner    ChurnerVars
	Dispersers []DisperserVars
	Batcher    []BatcherVars
	Encoder    []EncoderVars
	Operators  []OperatorVars
	Stakers    []Staker
	Retriever  RetrieverVars
	Controller ControllerVars
	Relays     []RelayVars
	Proxy      ProxyVars

	localstackEndpoint string
	localstackRegion   string

	// DisperserAddress is the address of disperser 0 (aka the only disperser at the current time)
	DisperserAddress gethcommon.Address

	// DisperserKMSKeyID is the KMS key ID used to encrypt disperser data
	DisperserKMSKeyID string
}

func (env *Config) IsEigenDADeployed() bool {
	return env.EigenDA.ServiceManager != ""
}

func ReadTestConfig(testName, rootPath string) (testEnv *Config) {
	rootPath, err := filepath.Abs(rootPath)
	if err != nil {
		log.Panicf("Error %s:", err.Error())
	}

	testPath := filepath.Join(rootPath, "inabox/testdata/"+testName)

	configPath := testPath + "/config.lock.yaml"
	if _, err := os.Stat(configPath); err != nil {
		configPath = testPath + "/config.yaml"
	}

	// Initialize testEnv before using it
	testEnv = &Config{}

	data, err := readFile(configPath)
	if err != nil {
		logger.Fatal("Error reading config file", "error", err)
	}

	err = yaml.Unmarshal(data, &testEnv)
	if err != nil {
		logger.Fatal("Error unmarshaling config", "error", err)
	}
	testEnv.TestName = testName
	testEnv.Path = testPath
	testEnv.rootPath = rootPath

	return
}

func (env *Config) SaveTestConfig() {
	obj, _ := yaml.Marshal(env)
	if err := writeFile(env.Path+"/config.lock.yaml", obj); err != nil {
		logger.Fatal("Error writing config.lock.yaml", "error", err)
	}
}
