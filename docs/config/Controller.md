<!-- Code generated by config_document_generator.go. DO NOT EDIT BY HAND. -->

# Controller Configuration

## Required Fields

| Name | Type | Description |
|------|------|-------------|
| $${\color{red}\texttt{AwsClient.AccessKey}}$$<br>`CONTROLLER_AWS_CLIENT_ACCESS_KEY` | `string` | AccessKey to use when interacting with S3. |
| $${\color{red}\texttt{AwsClient.Region}}$$<br>`CONTROLLER_AWS_CLIENT_REGION` | `string` | Region is the region to use when interacting with S3. Default is "us-east-2". |
| $${\color{red}\texttt{AwsClient.SecretAccessKey}}$$<br>`CONTROLLER_AWS_CLIENT_SECRET_ACCESS_KEY` | `string` | SecretAccessKey to use when interacting with S3. |
| $${\color{red}\texttt{ChainState.Endpoint}}$$<br>`CONTROLLER_CHAIN_STATE_ENDPOINT` | `string` | The Graph endpoint |
| $${\color{red}\texttt{ContractDirectoryAddress}}$$<br>`CONTROLLER_CONTRACT_DIRECTORY_ADDRESS` | `string` | The contract directory contract address, which is used to derive other EigenDA contract addresses. |
| $${\color{red}\texttt{DispersalRequestSigner.KeyID}}$$<br>`CONTROLLER_DISPERSAL_REQUEST_SIGNER_KEY_ID` | `string` | KeyID is the AWS KMS key identifier used for signing requests. Optional if PrivateKey is provided. |
| $${\color{red}\texttt{DispersalRequestSigner.PrivateKey}}$$<br>`CONTROLLER_DISPERSAL_REQUEST_SIGNER_PRIVATE_KEY` | `string` | PrivateKey is a hex-encoded private key for local signing (without 0x prefix). Optional if KeyID is provided. |
| $${\color{red}\texttt{DispersalRequestSigner.Region}}$$<br>`CONTROLLER_DISPERSAL_REQUEST_SIGNER_REGION` | `string` | Region is the AWS region where the KMS key is located (e.g., "us-east-1"). Required if using KMS. |
| $${\color{red}\texttt{DynamoDBTableName}}$$<br>`CONTROLLER_DYNAMO_DB_TABLE_NAME` | `string` | The name of the DynamoDB table used to store "core" metadata (i.e. blob statuses, signatures, etc.). |
| $${\color{red}\texttt{Encoder.AvailableRelays}}$$<br>`CONTROLLER_ENCODER_AVAILABLE_RELAYS` | `[]uint32` | AvailableRelays is the list of relay keys that can be assigned to blobs. Must not be empty. |
| $${\color{red}\texttt{Encoder.EncoderAddress}}$$<br>`CONTROLLER_ENCODER_ENCODER_ADDRESS` | `string` | EncoderAddress is the network address of the encoder service (e.g., "localhost:50051"). Must not be empty. |
| $${\color{red}\texttt{EthClient.RPCURLs}}$$<br>`CONTROLLER_ETH_CLIENT_RPCURLS` | `[]string` | A list of RPC URL endpoints to connect to the Ethereum chain. |
| $${\color{red}\texttt{SigningRateDynamoDbTableName}}$$<br>`CONTROLLER_SIGNING_RATE_DYNAMO_DB_TABLE_NAME` | `string` | The name of the DynamoDB table used to store signing rate data. |

## Optional Fields

| Name | Type<br>Default | Description |
|------|--------------|-------------|
| $${\color{red}\texttt{AttestationTimeout}}$$<br>`CONTROLLER_ATTESTATION_TIMEOUT` | `Duration`<br>`45s` | AttestationTimeout is the maximum time to wait for a single node to provide a signature. Must be positive. |
| $${\color{red}\texttt{AwsClient.EndpointURL}}$$<br>`CONTROLLER_AWS_CLIENT_ENDPOINT_URL` | `string`<br>`""` | EndpointURL of the S3 endpoint to use. If this is not set then the default AWS S3 endpoint will be used. |
| $${\color{red}\texttt{AwsClient.FragmentParallelismConstant}}$$<br>`CONTROLLER_AWS_CLIENT_FRAGMENT_PARALLELISM_CONSTANT` | `int`<br>`0` | This is a deprecated setting and can be ignored. |
| $${\color{red}\texttt{AwsClient.FragmentParallelismFactor}}$$<br>`CONTROLLER_AWS_CLIENT_FRAGMENT_PARALLELISM_FACTOR` | `int`<br>`0` | This is a deprecated setting and can be ignored. |
| $${\color{red}\texttt{BatchAttestationTimeout}}$$<br>`CONTROLLER_BATCH_ATTESTATION_TIMEOUT` | `Duration`<br>`55s` | BatchAttestationTimeout is the maximum time to wait for all nodes to provide signatures for a batch. Must be positive and must be longer or equal to the AttestationTimeout. |
| $${\color{red}\texttt{BatchMetadataUpdatePeriod}}$$<br>`CONTROLLER_BATCH_METADATA_UPDATE_PERIOD` | `Duration`<br>`1m0s` | BatchMetadataUpdatePeriod is the interval between attempts to refresh batch metadata (reference block number and operator state). Since this changes at most once per eth block, values shorter than 10 seconds are not useful. In practice, checking every several minutes is sufficient. Must be positive. |
| $${\color{red}\texttt{BlobDispersalQueueSize}}$$<br>`CONTROLLER_BLOB_DISPERSAL_QUEUE_SIZE` | `uint32`<br>`1024` | BlobDispersalQueueSize is the maximum number of blobs that can be queued for dispersal. |
| $${\color{red}\texttt{BlobDispersalRequestBackoffPeriod}}$$<br>`CONTROLLER_BLOB_DISPERSAL_REQUEST_BACKOFF_PERIOD` | `Duration`<br>`50ms` | BlobDispersalRequestBackoffPeriod is the delay between fetch attempts when there are no blobs ready for dispersal. |
| $${\color{red}\texttt{BlobDispersalRequestBatchSize}}$$<br>`CONTROLLER_BLOB_DISPERSAL_REQUEST_BATCH_SIZE` | `uint32`<br>`32` | BlobDispersalRequestBatchSize is the number of blob metadata items to fetch from the store in a single request. Must be at least 1. |
| $${\color{red}\texttt{ChainState.MaxRetries}}$$<br>`CONTROLLER_CHAIN_STATE_MAX_RETRIES` | `int`<br>`0` | The maximum number of retries to pull data from The Graph |
| $${\color{red}\texttt{ChainState.PullInterval}}$$<br>`CONTROLLER_CHAIN_STATE_PULL_INTERVAL` | `Duration`<br>`0s` | The interval to pull data from The Graph |
| $${\color{red}\texttt{CollectDetailedValidatorSigningMetrics}}$$<br>`CONTROLLER_COLLECT_DETAILED_VALIDATOR_SIGNING_METRICS` | `bool`<br>`true` | If true, validators that DON'T have a human-friendly name remapping will be reported as their full validator ID in metrics.<br><br>If false, validators that DON'T have a human-friendly name remapping will be reported as "0x0" in metrics.<br><br>NOTE: No matter the value of this field, validators that DO have a human-friendly name remapping will be reported as their remapped name in metrics. If you must reduce metric cardinality by reporting ALL validators as "0x0", you shouldn't define any human-friendly name remappings. |
| $${\color{red}\texttt{ControllerReadinessProbePath}}$$<br>`CONTROLLER_CONTROLLER_READINESS_PROBE_PATH` | `string`<br>`""` | The HTTP path to use for the controller readiness probe. |
| $${\color{red}\texttt{DispersalRequestSigner.Endpoint}}$$<br>`CONTROLLER_DISPERSAL_REQUEST_SIGNER_ENDPOINT` | `string`<br>`""` | Endpoint is an optional custom AWS KMS endpoint URL. If empty, the standard AWS KMS endpoint is used. This is primarily useful for testing with LocalStack or other custom KMS implementations. Default is empty. |
| $${\color{red}\texttt{DisperserID}}$$<br>`CONTROLLER_DISPERSER_ID` | `uint32`<br>`0` | DisperserID is the unique identifier for this disperser instance. |
| $${\color{red}\texttt{DisperserStoreChunksSigningDisabled}}$$<br>`CONTROLLER_DISPERSER_STORE_CHUNKS_SIGNING_DISABLED` | `bool`<br>`false` | If true, the disperser will not sign StoreChunks requests before sending them to validators. |
| $${\color{red}\texttt{EnablePerAccountBlobStatusMetrics}}$$<br>`CONTROLLER_ENABLE_PER_ACCOUNT_BLOB_STATUS_METRICS` | `bool`<br>`true` | If true, accounts that DON'T have a human-friendly name remapping will be reported as their full account ID in metrics.<br><br>If false, accounts that DON'T have a human-friendly name remapping will be reported as "0x0" in metrics.<br><br>NOTE: No matter the value of this field, accounts that DO have a human-friendly name remapping will be reported as their remapped name in metrics. If you must reduce metric cardinality by reporting ALL accounts as "0x0", you shouldn't define any human-friendly name remappings. |
| $${\color{red}\texttt{Encoder.EncodingRequestTimeout}}$$<br>`CONTROLLER_ENCODER_ENCODING_REQUEST_TIMEOUT` | `Duration`<br>`0s` | EncodingRequestTimeout is the maximum time to wait for a single encoding request to complete. Must be positive. |
| $${\color{red}\texttt{Encoder.MaxNumBlobsPerIteration}}$$<br>`CONTROLLER_ENCODER_MAX_NUM_BLOBS_PER_ITERATION` | `int32`<br>`0` | MaxNumBlobsPerIteration is the maximum number of blobs to pull and encode in each iteration. Must be at least 1. |
| $${\color{red}\texttt{Encoder.NumConcurrentRequests}}$$<br>`CONTROLLER_ENCODER_NUM_CONCURRENT_REQUESTS` | `int`<br>`0` | NumConcurrentRequests is the size of the worker pool for processing encoding requests concurrently. Must be at least 1. |
| $${\color{red}\texttt{Encoder.NumEncodingRetries}}$$<br>`CONTROLLER_ENCODER_NUM_ENCODING_RETRIES` | `int`<br>`0` | NumEncodingRetries is the number of times to retry encoding a blob after the initial attempt fails. A value of 0 means no retries (only the initial attempt). Must be non-negative. |
| $${\color{red}\texttt{Encoder.NumRelayAssignment}}$$<br>`CONTROLLER_ENCODER_NUM_RELAY_ASSIGNMENT` | `uint16`<br>`0` | NumRelayAssignment is the number of relays to assign to each blob. Must be at least 1 and cannot exceed the length of AvailableRelays. |
| $${\color{red}\texttt{Encoder.PerAccountMetrics}}$$<br>`CONTROLLER_ENCODER_PER_ACCOUNT_METRICS` | `bool`<br>`false` | If true, accounts that DON'T have a human-friendly name remapping will be reported as their full account ID in metrics.<br><br>If false, accounts that DON'T have a human-friendly name remapping will be reported as "0x0" in metrics.<br><br>NOTE: No matter the value of this field, accounts that DO have a human-friendly name remapping will be reported as their remapped name in metrics. If you must reduce metric cardinality by reporting ALL accounts as "0x0", you shouldn't define any human-friendly name remappings. |
| $${\color{red}\texttt{Encoder.PullInterval}}$$<br>`CONTROLLER_ENCODER_PULL_INTERVAL` | `Duration`<br>`0s` | PullInterval is how frequently the EncodingManager polls for new blobs to encode. Must be positive. |
| $${\color{red}\texttt{Encoder.StateRefreshInterval}}$$<br>`CONTROLLER_ENCODER_STATE_REFRESH_INTERVAL` | `Duration`<br>`0s` | StateRefreshInterval is how frequently the manager refreshes blob version parameters from the chain. Must be positive. |
| $${\color{red}\texttt{Encoder.StoreTimeout}}$$<br>`CONTROLLER_ENCODER_STORE_TIMEOUT` | `Duration`<br>`0s` | StoreTimeout is the maximum time to wait for blob metadata store operations. Must be positive. |
| $${\color{red}\texttt{EthClient.NumConfirmations}}$$<br>`CONTROLLER_ETH_CLIENT_NUM_CONFIRMATIONS` | `int`<br>`0` | Number of block confirmations to wait for. |
| $${\color{red}\texttt{EthClient.NumRetries}}$$<br>`CONTROLLER_ETH_CLIENT_NUM_RETRIES` | `int`<br>`0` | Number of maximal retry for each rpc call after failure/ |
| $${\color{red}\texttt{EthClient.PrivateKeyString}}$$<br>`CONTROLLER_ETH_CLIENT_PRIVATE_KEY_STRING` | `string`<br>`""` | Ethereum private key in hex string format. |
| $${\color{red}\texttt{EthClient.RetryDelay}}$$<br>`CONTROLLER_ETH_CLIENT_RETRY_DELAY` | `Duration`<br>`0s` | Time duration for linear retry delay increment. |
| $${\color{red}\texttt{FinalizationBlockDelay}}$$<br>`CONTROLLER_FINALIZATION_BLOCK_DELAY` | `uint64`<br>`75` | FinalizationBlockDelay is the number of blocks to wait before using operator state. This provides a hedge against chain reorganizations. |
| $${\color{red}\texttt{HeartbeatMonitor.FilePath}}$$<br>`CONTROLLER_HEARTBEAT_MONITOR_FILE_PATH` | `string`<br>`""` | FilePath is the path to the file where heartbeat status will be written. Required. |
| $${\color{red}\texttt{HeartbeatMonitor.MaxStallDuration}}$$<br>`CONTROLLER_HEARTBEAT_MONITOR_MAX_STALL_DURATION` | `Duration`<br>`0s` | MaxStallDuration is the maximum time allowed between heartbeats before a component is considered stalled. Required. |
| $${\color{red}\texttt{Indexer.PullInterval}}$$<br>`CONTROLLER_INDEXER_PULL_INTERVAL` | `Duration`<br>`0s` | The frequency to pull data from The Graph. |
| $${\color{red}\texttt{Log.AddSource}}$$<br>`CONTROLLER_LOG_ADD_SOURCE` | `bool`<br>`true` | Enable source code location |
| $${\color{red}\texttt{Log.Format}}$$<br>`CONTROLLER_LOG_FORMAT` | `LogFormat`<br>`json` | Format of the log output. Valid options are "json" and "text". |
| $${\color{red}\texttt{Log.Level}}$$<br>`CONTROLLER_LOG_LEVEL` | `LogLevel`<br>`debug` | Minimum level to log. Valid options are "debug", "info", "warn", and "error". |
| $${\color{red}\texttt{Log.NoColor}}$$<br>`CONTROLLER_LOG_NO_COLOR` | `bool`<br>`false` | Disable color, only supported with text handler (i.e. no color in json). |
| $${\color{red}\texttt{Log.TimeFormat}}$$<br>`CONTROLLER_LOG_TIME_FORMAT` | `string`<br>`""` | Time format, only supported with text handler |
| $${\color{red}\texttt{MaxBatchSize}}$$<br>`CONTROLLER_MAX_BATCH_SIZE` | `int32`<br>`32` | MaxBatchSize is the maximum number of blobs to include in a single batch for dispersal. Must be at least 1. |
| $${\color{red}\texttt{MaxDispersalAge}}$$<br>`CONTROLLER_MAX_DISPERSAL_AGE` | `Duration`<br>`45s` | MaxDispersalAge is the maximum age a dispersal request can be before it is discarded. Dispersals older than this duration are marked as Failed and not processed.<br><br>Age is determined by the BlobHeader.PaymentMetadata.Timestamp field, which is set by the client at dispersal request creation time (in nanoseconds since Unix epoch). |
| $${\color{red}\texttt{MaxDispersalFutureAge}}$$<br>`CONTROLLER_MAX_DISPERSAL_FUTURE_AGE` | `Duration`<br>`45s` | The maximum a blob dispersal's self-reported timestamp can be ahead of the local wall clock time. This is a preventative measure needed to prevent an attacker from sending far future timestamps that result in data being tracked for a long time. |
| $${\color{red}\texttt{MetricsPort}}$$<br>`CONTROLLER_METRICS_PORT` | `int`<br>`0` | The port on which to expose prometheus metrics. |
| $${\color{red}\texttt{NodeClientCacheSize}}$$<br>`CONTROLLER_NODE_CLIENT_CACHE_SIZE` | `int`<br>`400` | NodeClientCacheSize is the maximum number of node clients to cache for reuse. Must be at least 1. |
| $${\color{red}\texttt{NumConcurrentRequests}}$$<br>`CONTROLLER_NUM_CONCURRENT_REQUESTS` | `int`<br>`600` | NumConcurrentRequests is the size of the worker pool for processing dispersal requests concurrently. Must be at least 1. |
| $${\color{red}\texttt{Payment.OnDemand.MaxLedgers}}$$<br>`CONTROLLER_PAYMENT_ON_DEMAND_MAX_LEDGERS` | `int`<br>`0` | The maximum number of OnDemandLedger entries to be kept in the LRU cache |
| $${\color{red}\texttt{Payment.OnDemand.OnDemandTableName}}$$<br>`CONTROLLER_PAYMENT_ON_DEMAND_ON_DEMAND_TABLE_NAME` | `string`<br>`""` | The name of the dynamo table where on-demand payment information is stored |
| $${\color{red}\texttt{Payment.OnDemand.UpdateInterval}}$$<br>`CONTROLLER_PAYMENT_ON_DEMAND_UPDATE_INTERVAL` | `Duration`<br>`0s` | Interval for checking for payment updates |
| $${\color{red}\texttt{Payment.PerAccountMetrics}}$$<br>`CONTROLLER_PAYMENT_PER_ACCOUNT_METRICS` | `bool`<br>`false` | If true, enable a metric per user account for payment validation and authorization. Resulting metric may potentially have high cardinality. |
| $${\color{red}\texttt{Payment.Reservation.BucketCapacityPeriod}}$$<br>`CONTROLLER_PAYMENT_RESERVATION_BUCKET_CAPACITY_PERIOD` | `Duration`<br>`0s` | Duration used to calculate bucket capacity when creating new reservation ledgers |
| $${\color{red}\texttt{Payment.Reservation.MaxLedgers}}$$<br>`CONTROLLER_PAYMENT_RESERVATION_MAX_LEDGERS` | `int`<br>`0` | The maximum number of ReservationLedger entries to be kept in the LRU cache. This may be automatically increased at runtime if premature ledger evictions are detected by the underlying cache. |
| $${\color{red}\texttt{Payment.Reservation.OverfillBehavior}}$$<br>`CONTROLLER_PAYMENT_RESERVATION_OVERFILL_BEHAVIOR` | `OverfillBehavior`<br>`` | How to handle requests that would overfill the bucket |
| $${\color{red}\texttt{Payment.Reservation.UpdateInterval}}$$<br>`CONTROLLER_PAYMENT_RESERVATION_UPDATE_INTERVAL` | `Duration`<br>`0s` | Interval for checking for payment updates |
| $${\color{red}\texttt{PullInterval}}$$<br>`CONTROLLER_PULL_INTERVAL` | `Duration`<br>`1s` | PullInterval is how frequently the Dispatcher polls for new encoded blobs to batch and dispatch. Must be positive. |
| $${\color{red}\texttt{Server.GrpcPort}}$$<br>`CONTROLLER_SERVER_GRPC_PORT` | `uint16`<br>`0` | Port that the gRPC server listens on |
| $${\color{red}\texttt{Server.MaxGRPCMessageSize}}$$<br>`CONTROLLER_SERVER_MAX_GRPC_MESSAGE_SIZE` | `int`<br>`0` | Maximum size of a gRPC message that the server will accept (in bytes) |
| $${\color{red}\texttt{Server.MaxIdleConnectionAge}}$$<br>`CONTROLLER_SERVER_MAX_IDLE_CONNECTION_AGE` | `Duration`<br>`0s` | Maximum time a connection can be idle before it is closed. |
| $${\color{red}\texttt{Server.RequestMaxFutureAge}}$$<br>`CONTROLLER_SERVER_REQUEST_MAX_FUTURE_AGE` | `Duration`<br>`0s` | Maximum age of a request in the future that the server will accept. Requests with timestamps too far in the future will be rejected. |
| $${\color{red}\texttt{Server.RequestMaxPastAge}}$$<br>`CONTROLLER_SERVER_REQUEST_MAX_PAST_AGE` | `Duration`<br>`0s` | Maximum age of a request in the past that the server will accept. Requests older than this will be rejected to prevent replay attacks. |
| $${\color{red}\texttt{SignatureTickInterval}}$$<br>`CONTROLLER_SIGNATURE_TICK_INTERVAL` | `Duration`<br>`50ms` | SignatureTickInterval is how frequently attestations are updated in the blob metadata store as signature gathering progresses. Must be positive. |
| $${\color{red}\texttt{SignificantSigningThresholdFraction}}$$<br>`CONTROLLER_SIGNIFICANT_SIGNING_THRESHOLD_FRACTION` | `float64`<br>`0.55` | SignificantSigningThresholdFraction is a configurable "important" signing threshold fraction. Used to track signing metrics and understand system performance. If the value is 0, special handling for this threshold is disabled. Must be between 0.0 and 1.0. |
| $${\color{red}\texttt{SigningRateBucketSpan}}$$<br>`CONTROLLER_SIGNING_RATE_BUCKET_SPAN` | `Duration`<br>`10m0s` | The duration of each signing rate bucket. Smaller buckets yield more granular data, at the cost of memory and storage overhead. |
| $${\color{red}\texttt{SigningRateFlushPeriod}}$$<br>`CONTROLLER_SIGNING_RATE_FLUSH_PERIOD` | `Duration`<br>`1m0s` | The period at which signing rate data is flushed to persistent storage. |
| $${\color{red}\texttt{SigningRateRetentionPeriod}}$$<br>`CONTROLLER_SIGNING_RATE_RETENTION_PERIOD` | `Duration`<br>`336h0m0s` | The amount of time to retain signing rate data. |
| $${\color{red}\texttt{UseGraph}}$$<br>`CONTROLLER_USE_GRAPH` | `bool`<br>`false` | Whether or not to use subgraph. |
| $${\color{red}\texttt{UserAccountRemappingFilePath}}$$<br>`CONTROLLER_USER_ACCOUNT_REMAPPING_FILE_PATH` | `string`<br>`""` | The file path to a yaml file that maps user accounts (i.e. the parties submitting blobs) to human-friendly names, which are used for metrics. |
| $${\color{red}\texttt{ValidatorIdRemappingFilePath}}$$<br>`CONTROLLER_VALIDATOR_ID_REMAPPING_FILE_PATH` | `string`<br>`""` | The file path to a yaml file that maps validator IDs to human-friendly names, which are used for metrics. |

